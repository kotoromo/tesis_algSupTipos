\documentclass{article}
\usepackage{geometry}
 \geometry{
 a4paper,
 total={170mm,257mm},
 left=20mm,
 top=20mm,
 }
\usepackage{array}
\usepackage{graphicx}
\usepackage[spanish,es-noshorthands, es-lcroman]{babel}
\usepackage[utf8]{inputenc}
\usepackage{amsthm}
\usepackage{amsfonts}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{enumerate}
\usepackage{amsmath}
\usepackage{calrsfs}
\usepackage{mathrsfs}
\usepackage{hyperref}
\usepackage{graphicx}
\usepackage{float}
\usepackage{tikz-cd}
\usepackage{todonotes}
\usepackage{tikz}
\usepackage{tikz-qtree}
\usepackage{pict2e}
\usepackage{subcaption}
\usepackage{wrapfig}
\usepackage{cite}
\usepackage[skins]{tcolorbox}
\usepackage{bussproofs}
\usepackage{bussproofs-extra}
\usepackage{bbold}
\usepackage{quiver}
\graphicspath{ {./img/} }
\newtcolorbox{sfwt}[2][]{%
  enhanced,colback=white,colframe=black,coltitle=black,
  sharp corners,boxrule=0.4pt,
  fonttitle=\itshape,
  attach boxed title to top left={yshift=-0.3\baselineskip-0.4pt,xshift=2mm},
  boxed title style={tile,size=minimal,left=0.5mm,right=0.5mm,
    colback=white,before upper=\strut},
  title=#2,#1
}

\newcommand{\overbar}[1]{\mkern 1.5mu\overline{\mkern-1.5mu#1\mkern-1.5mu}\mkern 1.5mu}

\DeclareMathOperator{\dom}{dom}
\DeclareMathOperator{\cod}{cod}
\DeclareMathOperator{\Id}{Id}
\DeclareMathOperator{\ran}{ran}
\DeclareMathOperator{\im}{ran}
\DeclareMathOperator{\cam}{cam}
\DeclareMathOperator{\sop}{Sop}
\DeclareMathOperator{\inr }{inr }
\DeclareMathOperator{\inl}{inl}
\DeclareMathOperator{\ind}{ind}
\DeclareMathOperator{\pair}{pair}
\DeclareMathOperator{\pr}{pr}

\graphicspath{ {./img/} }


\begin{document}

\theoremstyle{definition}
\newtheorem{definition}{Definición}[section]
\newtheorem{theorem}{Teorema}[section]
\newtheorem{proposition}{Proposición}[section]
\newtheorem{corollary}{Corolario}[theorem]
\newtheorem{lemma}[theorem]{Lema}
\newtheorem{remark}{Observación}
\newtheorem*{notation}{Notación}
\newtheorem{example}{Ejemplo}[section]
\newtheorem{exercise}{Juego}[section]
\newtheorem{axiom}{Axioma}

%%%%%%% DEFINITIONS %%%%%%%%%
\newcommand{\bb}[1]{\mathbb{#1}}
\newcommand{\set}[1]{\{#1\}}
\newcommand{\seq}[1]{\{#1\}_{n\in\bb{N}}}
\newcommand{\picopar}[1]{\langle #1 \rangle}
\newcommand{\card}[1]{\vert #1 \vert}
\newcommand{\RestrictTo}[1]{\restriction_{#1}}
\newcommand{\norm}[1]{\left\lVert{#1}\right\rVert}
\newcommand{\type}{\mathrm{type}}
\newcommand{\const}{\mathrm{const}}

\title{Álgebra Superior: Una perspectiva típica}
\author{Nicky García Fierros}

\maketitle
\tableofcontents

\section{Introducción}
\subsection{¿Teoría de tipos? ¿Y la teoría de conjuntos?}

\section{Algunos conceptos categóricos}
\subsection{Introducción}
La idea de esta sección es presentar simplemente algunos conceptos de la teoría
de categorías a los cuales se harán referencia a lo largo del texto. Aunque es
posible introducir el contenido principal del texto sin hacer mención explícita 
a las categorías, el autor encuentra fascinante, bella y esclarecedora la 
conexión que existe entre la lógica matemática, la teoría de tipos y la teoría 
de categorías y por lo tanto se ha decidido incluir esta sección así como las
referencias explícitas a las categorías a lo largo del texto. Además, otra
motivación para incluir esta sección en la tesis es que lamentablemente en la
facultad de ciencias no es común que se impartan cursos de forma obligatoria de
teoría de categorías por lo que el autor considera que es irrazonable asumir que
la lectora o el lector esté familiarizado con las categorías.

Dado que el principal contenido de este texto no son las categorías sino la
teoría homotópica de tipos y su aplicación a la formalización de matemáticas,
no se ahondará en las categorías más allá de lo necesario para exhibir la
conexión entre las categorías y la teoría de tipos y la riqueza que esta
introduce a la teoría; sin embargo, en tanto que el propósito también es aquel
de motivar al lector o a la lectora a explorar estas conexiones, se incluirán
referencias a textos donde se puede profundizar en el tema.

\subsection{Primeros conceptos}

\begin{definition}[Categoría]
    Una categoría $\mathcal{C}$ consiste de la siguiente información:
    \begin{enumerate}
        \item Una colección de objetos $\mathrm{Obj}(\mathcal{C})$.
        \item Para cada par de objetos $A, B \in \mathrm{Obj}(\mathcal{C})$ una colección de morfismos $\mathcal{C}(A, B)$.
        \item Una noción de composición entre morfismos de tal modo que si $f \in \mathcal{C}(A, B)$ y $g \in \mathcal{C}(B, C)$ entonces
        existe un morfismo $gf \in \mathcal{C}(A, C)$.
        % https://q.uiver.app/#q=WzAsMyxbMCwwLCJBIl0sWzEsMCwiQiJdLFsyLDAsIkMiXSxbMCwxLCJmIl0sWzEsMiwiZyJdLFswLDIsImdmIiwyLHsiY3VydmUiOjN9XV0=
        \[\begin{tikzcd}
	        A & B & C
	        \arrow["f", from=1-1, to=1-2]
	        \arrow["g", from=1-2, to=1-3]
	        \arrow["gf"', curve={height=18pt}, from=1-1, to=1-3]
        \end{tikzcd}\]
    \end{enumerate}
    
\end{definition}

\begin{definition}[Categoría cartesiana cerrada (CCC) \cite{Lambek1986-LAMITH-2}]
   Una categoría $\mathcal{C}$ es cartesiana cerrada o $CCC$ si
   \begin{itemize}
    \item Existe un objeto terminal $\mathbb{1}$.
    \item Existen operaciones $(\_\times\_)$ y $(\_)^{(\_)}$ tales que:
    \begin{itemize}
        \item Para toda $A \in \mathrm{Obj}(\mathcal{C})$ existe una único 
              morfimso $A \xrightarrow{!A} \mathbb{1}$.
        \item $\mathcal{C}(C, A \times B) \cong \mathcal{C}(C, A) \times \mathcal{C}(C, B)$.
        \item $\mathcal{C}(A, C^{B}) \cong \mathcal{C}(A \times B, C)$.
    \end{itemize}
   \end{itemize}
\end{definition}
\todo{Definir $B^{A}$ para argumentar el punto 3 de la definición de CCC y mostrar que Sets es CCC}
\begin{definition}[Topos]
    Una categoría $\mathcal{E}$ es un topos si tiene la siguiente estructura:
    \begin{itemize}
        \item Para cada diagrama $X \rightarrow B \leftarrow Y$ existe un
              producto fibrado.
        \item Tiene un objeto terminal $\mathbb{1}$.
        \item Existe un objeto $\Omega$ y una flecha 
              $\top : \mathbb{1} \rightarrow \Omega$ tal que para cualquier 
              monomofismo $m : S \rightarrowtail B$ existe una única flecha
              $\chi_B: B \rightarrow \Omega \in \mathcal{E}$ tal que el siguiente
              diagrama es un producto fibrado:
        % https://q.uiver.app/#q=WzAsNCxbMCwwLCJTIl0sWzEsMCwiMSJdLFswLDEsIkIiXSxbMSwxLCJcXE9tZWdhIl0sWzEsMywiXFx0b3AiLDAseyJzdHlsZSI6eyJ0YWlsIjp7Im5hbWUiOiJtb25vIn19fV0sWzIsMywiXFx2YXJwaGkiLDJdLFswLDIsIm0iLDIseyJzdHlsZSI6eyJ0YWlsIjp7Im5hbWUiOiJtb25vIn19fV0sWzAsMV0sWzAsMywiIiwxLHsic3R5bGUiOnsibmFtZSI6ImNvcm5lciJ9fV1d
        \[\begin{tikzcd}
	        S & \mathbb{1} \\
	        B & \Omega
	        \arrow["\top", tail, from=1-2, to=2-2]
	        \arrow["\chi_B"', from=2-1, to=2-2]
	        \arrow["m"', tail, from=1-1, to=2-1]
	        \arrow[from=1-1, to=1-2]
	        \arrow["\lrcorner"{anchor=center, pos=0.125}, draw=none, from=1-1, to=2-2]
        \end{tikzcd}\]
        \item Para cualquier objeto $B$ existen un objeto $P\ B$ y una flecha 
        $\in_B : B \times P\ B \rightarrow \Omega$ tal que para cualquier flecha
        $f : B \times A \rightarrow \Omega$ existe una única flecha 
        $g : A \rightarrow P\ B$ tal que el siguiente diagrama conmuta:
        % https://q.uiver.app/#q=WzAsNixbMCwwLCJBIl0sWzAsMSwiUFxcIEIiXSxbMiwwLCJCXFx0aW1lcyBBIl0sWzIsMSwiQiBcXHRpbWVzIFBcXCBCIl0sWzMsMSwiXFxPbWVnYSJdLFszLDAsIlxcT21lZ2EiXSxbMCwxLCJcXGV4aXN0cyEgZyJdLFsyLDUsIlxcZm9yYWxsIGYiXSxbMyw0LCJcXGluX0IiLDJdLFsyLDMsIklkXFx0aW1lcyBnIiwyXSxbNSw0LCIiLDAseyJsZXZlbCI6Miwic3R5bGUiOnsiaGVhZCI6eyJuYW1lIjoibm9uZSJ9fX1dXQ==
        \[\begin{tikzcd}
	        A && {B\times A} & \Omega \\
	        {P\ B} && {B \times P\ B} & \Omega
	        \arrow["{\exists! g}", from=1-1, to=2-1]
	        \arrow["{\forall f}", from=1-3, to=1-4]
	        \arrow["{\in_B}"', from=2-3, to=2-4]
	        \arrow["{Id\times g}"', from=1-3, to=2-3]
	        \arrow[Rightarrow, no head, from=1-4, to=2-4]
        \end{tikzcd}\]
    \end{itemize}
\end{definition}

\begin{remark}
    Un topos en particular es una categoría cartesiana cerrada.
\end{remark}

\begin{definition}[Limite]
    
\end{definition}

\begin{definition}[Transformación natural]
    
\end{definition}

\begin{definition}[Adjunción]
    
\end{definition}

\section{Teoría de tipos dependientes y la formalización de matemáticas en Agda}
\subsection{Introducción}
\todo{Meterle más paja a esto}
La teoría homotópica de tipos es un área de estudio de las matemáticas relativamente nueva. 
Esta área de estudio contempla herramientas de la teoría de los lenguajes de programación, el álgebra, la teoría de categorías, la lógica matemática y la topología.
El poder expresivo del lenguaje formal empleado por la teoría de tipos homotópica así como su fundamento teórico es tan expresivo y general que permite
ofrecer una teoría alternativa a la teoría de conjuntos para fundamentar las matemáticas. Dentro de las ventajas que brinda emplear este lenguaje
está la posibilidad de utilizar computadoras para verificar la correctud de demostraciones matemáticas.

Es importante notar que al ser ésta una teoría constructiva desde su concepción, técnicas propias que dependen de axiomas o teoremas no constructivos como lo son
la ley del tercer excluido, o el teorema de elección generalizado, no se encuentran disponibles en todos los contextos a diferencia de las "matemáticas clásicas".

En esta segunda parte del trabajo se explorarán de forma breve y concisa temas de la teoría homotópica de tipos con el objetivo
de proponer y dar una base teórica para una formalización del temario de álgebra superior.

\subsection{Teoría de tipos dependientes}
    \subsubsection{Juicios, contextos y derivaciones}
        En la teoría de tipos se emplea un lenguaje formal que está basado en la deducción natural pues es un sistema en el que se cuenta
        con reglas de inferencia que se pueden combinar para formar derivaciones. Las derivaciones nos importan porque son el principal
        mecanismo para producir \textit{términos} de un tipo determinado.
        
        Como es de esperarse del título que carga la teoría de tipos, un 
        \textbf{tipo} es un objeto primitivo de la teoría de tipos de la misma 
        forma que un conjunto es un objeto primitivo de la teoría de conjuntos,
        y se suele definir mediante una serie de pasos a seguir para construir 
        un elemento del tipo, o en otras palabras, si se tiene un entendimiento
        sobre qué significa ser un elemento del tipo. 
        Como podrá usted, lector o lectora, darse una idea desde el párrafo 
        anterior, los tipos pueden tener (o no) términos. Como se mencionó 
        antes, un término es el resultado de la aplicación de reglas de 
        inferencia y, como el autor no desea arruinar el placentero proceso de 
        entender a un nuevo objeto matemático, conforme avancemos en este 
        trabajo floreceran distintas formas útiles de pensar a los tipos y sus 
        términos.

        Entenderemos por una \textbf{derivación} a una sucesión de aplicaciones de \textbf{reglas de inferencia}.

        Comenzamos por definir precisamente qué es un juicio en este lenguaje.
        \begin{definition}[Juicios, contextos]
            Un \textbf{juicio} es alguna expresión de la forma:
            \begin{enumerate}
                \item $\Gamma \vdash A\ \type$ (Desde $\Gamma$ se deduce que $A$ es un tipo)
                \item $\Gamma \vdash a : A\ \type$ (Desde $\Gamma$ se deduce que $a$ es un término de tipo $A$)
                \item $\Gamma \vdash A \equiv B\ \type$ (Desde $\Gamma$ se deduce que $A$ es un tipo juiciosamente equivalente al tipo $B$)
                \item $\Gamma \vdash a \equiv b\ : A$ (Desde $\Gamma$ se deduce que los términos $a$ y $b$ de tipo $A$ son juiciosamente equivalentes)
            \end{enumerate}

            donde $\Gamma$ es una lista finita de declaraciones de variables tales que para cada $1 \leq k \leq n$
            se puede derivar el juicio
            $$
                x_1 : A_1, x_2 : A_2(x_1), \dots, x_k : A_k(x_1, x_2, \dots, x_{k-1}) \vdash A_{k+1}(x_1, x_2, \dots, x_{k-1}, x_k)\ \type
            $$
            y recibe el nombre de \textbf{contexto}; y lo que se encuentra a la derecha del símbolo $\vdash$ 
            (léase "desde \_ se deduce \_") recibe el nombre de \textbf{tesis de juicio}.
        \end{definition}

        Los contextos, de forma análoga a su rol en el cálculo de secuentes, 
        denotan los supuestos que se están considerando para obtener la tesis 
        de juicio. En tanto que los elementos potencialmente pueden ser 
        suposiciones que carecen de fundamento previamente derivado se les 
        suelen llamar \textit{variables}. Los juicios los pensamos como hechos, 
        a diferencia de las proposiciones; las cuales potencialmente son 
        verdaderas o falsas. Alternativamente llamaremos \textbf{elementos} a 
        los términos de un tipo dado, de modo que un juicio $a : A$ se puede 
        leer como $a$ es un elemento de tipo $A$.

        El orden en los contextos nos importa porque nos interesa mantener la
        noci\'{o}n de dependencia de una expresión con respecto a otra, de modo
        que contextos como

        $$
            \Gamma := \{f : A \supset B, A\ \type, B\ \type\}
        $$

        resultan particularmente peligrosos, pues dar\'{i}an a entender que
        $f : A \supset B$ es una prueba de $A \supset B$ sin contar antes del
        conocimiento de que $A$ y $B$ son tipos y entonces se presentar\'{i}a
        una situación semejante a la de suponer lo que se desea demostrar. El
        motivo por el cual la noción de dependencia es importante es porque en
        la teor\'{i}a de tipos de Per Martin-L\"{o}f se hace una distinci\'{o}n
        importante entre \textbf{juicios} y \textbf{proposiciones}\footnote{En 
        \cite{PerMartin-Lof98} se pueden leer las ideas originales que 
        concibieron a esta teoría.}. En los cursos de l\'{o}gica (y \'{a}lgebra 
        superior) se enseña que una proposición es una oraci\'{o}n para la cual 
        es posible asignar un valor de verdad (\textit{verdadero} o 
        \textit{falso} sea lo que signifique eso). Para los matem\'{a}ticos y
        l\'{o}gicos intuicionistas esta noción es incompleta en virtud de las
        dificultades que presenta el justificar las reglas para la formación de
        proposiciones mediante la cuantificaci\'{o}n sobre dominios infinitos \footnote{Necesito citar esto gg},\todo{Encontrar entre las refs donde se afirma esto (ademas del libro de Martin Lof)}
        por lo que se ofrece una noci\'{o}n alternativa para proposico\'{o}n:
        \begin{center}
            \textit{una proposici\'{o}n se define al exhibir una 
            demostraci\'{o}n para lo que se propone}
        \end{center}
        y
        \begin{center}
            \textit{una proposición es verdadera  si tiene una demostraci\'{o}n.}
        \end{center}
        \cite{PerMartin-Lof98}

        De este modo, cuando escribimos algún juicio, como por ejemplo
        $$
            \vdash a : A
        $$
        es porque \textbf{a : A est\'{a} demostrado}, y no estamos 
        hipotetizando. Por otro lado, lo que escribimos como combinaci\'{o}n de 
        s\'{i}mbolos l\'{o}gicos (por supuesto siguiendo las reglas de formación 
        de su gram\'{a}tica) y est\'{a} por verse su veracidad denominamos 
        proposiciones. Así, cuando en un contexto escribimos
        $$
            A\ \type, x : A, B(x)\ \type, y : B(x)\ \type, \dots
        $$
        estamos declarando que nuestras suposiciones son coherentes con el resto
        de nuestras reglas de formación en tanto que son resultado de 
        juicios anteriores.
        \begin{remark}
            Observe que nuestra definición de contexto permite la existencia de un contexto vacío pues por un argumento de vacuidad se verifica la
            satisfacibilidad de la propiedad de un contexto.
        \end{remark}
        \begin{remark}
            Obsérvese que la condición impuesta sobre un contexto se puede verificar de forma recursiva o inductiva:
            \begin{itemize}
                \item El caso base es mostrar que $x_1 : A_1$ se deduce desde el contexto vacío. Para afirmar que $x_1 : A_1$ es un juicio válido se debe haber deducido (o supuesto)
                que $A_1$ es un tipo en el contexto vacío.
                \item La clausula inductiva es codificada por la propiedad que define a un contexto.
            \end{itemize}

            Para verificar de forma recursiva que una lista de declaraciones de la forma 
            $$
                x_1 : A_1, x_2 : A_2(x_1), \dots, x_k : A_k(x_1, x_2, \dots, x_{k-1}) \vdash x_{k+1} : A_{k+1}(x_1, \dots, x_{k-1}, x_k)\ \type
            $$
            es un contexto basta probar que una lista de declaraciones de la forma
            $$
            x_1 : A_1, x_2 : A_2(x_1), \dots, x_k : A_{k-2}(x_1, x_2, \dots, x_{k-2}) \vdash x_{k} : A_{k}(x_1, \dots, x_{k-1})\ \type
            $$
            y así de forma sucesiva hasta dar con el caso base.
        \end{remark}

        \begin{definition}[Derivación]
            Una \textbf{derivación} es un árbol finito con raíz en el que cada vértice es una regla de inferencia válida.
            A la raíz del árbol se le llama \textbf{conclusión} y a las hojas \textbf{hipótesis}.
        \end{definition}

        Nos reservamos el derecho de poder definir nuevas reglas de inferencia a partir de otras, y diremos que estas nuevas reglas son \textbf{derivables}.
    
    \subsubsection{Familias de tipos}
    \todo{Poner el codigo en agda de esto}
        Una idea universal bastante útil es la de un "agrupamiento de agrupamientos"; ejemplos clásicos de este patrón de pensamiento son
        las familias de conjuntos; en teoría de conjuntos; y los enunciados; en lógica de primer órden. En la teoría de tipos dependientes
        de Per Martin-Löf contamos con un marco de trabajo que engloba esta idea, 
        llamada \textit{familia de tipos}.

        \begin{definition}[Familia de tipos]\label{def:familia_tipos}
            Si $A$ es un tipo en un contexto $\Gamma$, una \textbf{familia de tipos} $B(x)$ es un tipo en el contexto $\Gamma, x : A$ (o también diremos
            que $B(x)$ es un \textbf{tipo indizado sobre} $A$ en el contexto $\Gamma$) y
            escribimos formalmente este hecho como
            $$
                \Gamma, x : A \vdash B(x)\ \type
            $$

            y en su forma de regla de inferencia podemos \textbf{introducirla} como
            \begin{prooftree}
                \AxiomC{$\Gamma \vdash x : A$}
                \AxiomC{$\varnothing \vdash A\ \type$}
                \BinaryInfC{$B(x)\ \type$}
            \end{prooftree}

            Por comodidad se suele omitir el contexto vacío y solamente se escribe la tesis de juicio, de modo que escribimos:

            \begin{prooftree}
                \AxiomC{$\Gamma \vdash x : A$}
                \AxiomC{$A\ \type$}
                \BinaryInfC{$B(x)\ \type$}
            \end{prooftree}

            o si damos por obvio que $A$ tiene que ser un tipo para que el juicio $\Gamma \vdash x : A$ sea válido podemos solamente convenir escribir
            \begin{prooftree}
                \AxiomC{$\Gamma \vdash x : A$}
                \UnaryInfC{$\Gamma \vdash B(x)\ \type$}
            \end{prooftree}
        
            Por conveniencia y claridad, a partir de este punto emplearemos las convenciones de escritura que nos permiten obviar cosas a menos de que sea
            necesario para esclarecer.
        \end{definition}

        \begin{remark}
            Resulta bastante útil pensar a una familia de tipos como un tipo que varía según los términos de otro tipo. 
            Es decir, si abusamos de notación, podemos pensar a una familia de tipos como una función 
            \begin{align*}
                \mathrm{Term(A)} &\rightarrow \mathrm{Types}\\
                x : A &\mapsto B(x)\ \type
            \end{align*}
            Un un futuro no muy lejano se exhibirá cómo expresar este hecho de manera formal dentro del lenguaje de la teoría de tipos dependiente.
        \end{remark}

        Como es de esperarse que de una colecciones de colecciones podamos tomar \textit{una parte}, análogamente de una familia de tipos
        podemos considerar lo que llamaremos una \textbf{sección}.

        \begin{definition}[Sección de una familia de tipos]
            Si $B$ es una familia de tipos sobre $A$ en el contexto $\Gamma$, diremos que una \textbf{sección} de $B$ es un término $b(x) : B(x)$ en un contexto
            $\Gamma, x : A$. En símbolos:
            $$
                \Gamma, x : A \vdash b(x) : B(x)
            $$
            La \textbf{regla de introducción} asociada entonces es:

            \begin{prooftree}
                \AxiomC{$\Gamma \vdash x : A$}
                \AxiomC{$\Gamma, x : A \vdash B(x)\ \type$}
                \BinaryInfC{$\Gamma \vdash b(x) : B(x)$}
            \end{prooftree}
            Y podemos entenderla como:
            \textit{Si podemos deducir del contexto $\Gamma$ que $x$ es un término de tipo $A$ y que $B$ es una familia de tipos sobre $A$, 
            entonces podemos deducir desde $\Gamma$ que $b(x) : B(x)$ es una sección de $B$}.
        \end{definition}

        \begin{remark}
            Nótese que tanto el término como el tipo dependen del término 
            $x : A$, de modo que abusando de la notación podemos pensar a este 
            proceso como una función
            \begin{align*}
                \mathrm{Term(A)} \times (\mathrm{Term(A)} \rightarrow \mathrm{Types}) &\rightarrow \mathrm{Term}(B(x))\\
                \picopar{x : A\ ,\ x : A \mapsto B(x)\ \type}\mapsto b(x) : B(x)
            \end{align*}
        \end{remark}
        
    \subsubsection{Clases de reglas de inferencia}
        Las siguientes reglas de inferencia describen de forma explicita las 
        suposiciones de que hicimos en la definición \ref{def:familia_tipos}.
        Es de esperarse que, si tenemos en un contexto las variables 
        $A\ \type, x : A$, entonces desde ese mismo contexto podamos deducir
        $A\ \type$ y $x : A$ por separado.
        \begin{center}
            \AxiomC{$\Gamma, x : A \vdash B(x)\ \type$}
            \UnaryInfC{$\Gamma \vdash A\ \type$}
            \DisplayProof
            \hskip 1.5em
            \AxiomC{$\Gamma \vdash A \equiv B\ \type$}
            \UnaryInfC{$\Gamma \vdash A\ \type$}
            \DisplayProof
            \hskip 1.5em
            \AxiomC{$\Gamma \vdash A \equiv B\ \type$}
            \UnaryInfC{$\Gamma \vdash B\ \type$}
            \DisplayProof
        \end{center}
        
        \begin{center}
            \AxiomC{$\Gamma \vdash a \equiv b : A$}
            \UnaryInfC{$\Gamma \vdash a : A$}
            \DisplayProof
            \hskip 1.5em
            \AxiomC{$\Gamma \vdash a \equiv b : A$}
            \UnaryInfC{$\Gamma \vdash b : A$}
            \DisplayProof
            \hskip 1.5em
            \AxiomC{$\Gamma \vdash a : A$}
            \UnaryInfC{$\Gamma \vdash A\ \type$}
            \DisplayProof
        \end{center}

        En tanto que es de interés que la noción de 
        \textit{ser juiciosamente iguales} sea una buena noción de equivalencia, 
        es de esperarse que se postulen reglas que testifican que esta noción 
        satisface los axiomas de una relación de equivalencia. 
        \footnote{Esta noción de equivalencia fue concebida en términos de
        una equivalencia en cuanto a reducción, es decir, si tras aplicar reglas
        de inferencia a dos expresiones sintacticamente distintas se concluye \
        que ambas expresiones comparten una misma forma (normal) tras 
        simplificar dichas expresiones lo m\'{a}s posible, entonces ambas 
        expresiones son juiciosamente equivalentes 
        \cite{10.1093/oso/9780198501275.003.0010}\cite{MARTINLOF197573}.}

        \begin{center}
            \AxiomC{$\Gamma \vdash A\ \type$}
            \UnaryInfC{$\Gamma \vdash A\equiv A\ \type$}
            \DisplayProof
            \hskip 1.5em
            \AxiomC{$\Gamma \vdash A \equiv B\ \type$}
            \UnaryInfC{$\Gamma \vdash B \equiv A\ \type$}
            \DisplayProof
            %\hskip 1.5em
            %\AxiomC{$\Gamma \vdash A \equiv B\ \type$}
            %\AxiomC{$\Gamma \vdash B \equiv C\ \type$}
            %\BinaryInfC{$\Gamma \vdash A \equiv C\ \type$}
            %\DisplayProof
        \end{center}

        \begin{prooftree}
            \AxiomC{$\Gamma \vdash A \equiv B\ \type$}
            \AxiomC{$\Gamma \vdash B \equiv C\ \type$}
            \BinaryInfC{$\Gamma \vdash A \equiv C\ \type$}
        \end{prooftree}

        \begin{center}
            \AxiomC{$\Gamma \vdash a : A$}
            \UnaryInfC{$\Gamma \vdash a \equiv a : A$}
            \DisplayProof
            \hskip 1.5em
            \AxiomC{$\Gamma \vdash a \equiv b: A$}
            \UnaryInfC{$\Gamma \vdash b \equiv a : A$}
            \DisplayProof
            \hskip 1.5em
            \AxiomC{$\Gamma \vdash a \equiv b : A$}
            \AxiomC{$\Gamma \vdash b \equiv c : A$}
            \BinaryInfC{$\Gamma \vdash a \equiv c : A$}
            \DisplayProof
        \end{center}

        También es de esperarse que, si se tienen que dos tipos son juiciosamente equivalentes, y puedes deducir una tesis de juicio $\mathfrak{T}$
        a partir de una variable, entonces al intercambiar el tipo sobre el que tomas la variable por su equivalente la misma tesis de juicio
        debería poder deducirse.

        \begin{center}
            \AxiomC{$\Gamma \vdash A \equiv B \ \type$}
            \AxiomC{$\Gamma, x : A, \Theta \vdash \mathfrak{T}$}
            \RightLabel{ConvVar}
            \BinaryInfC{$\Gamma, x : B, \Theta \vdash \mathfrak{T}$}
            \DisplayProof
        \end{center}
        Donde $\Theta$ es una extensión cualquiera del contexto $\Gamma, x : A$.
        Por ejemplo en el caso en que $\mathfrak{T}$ es $C(x)\ \type$ tenemos
        \begin{center}
            \AxiomC{$\Gamma \vdash A \equiv B \ \type$}
            \AxiomC{$\Gamma, x : A, \Theta \vdash C(x)\ \type$}
            \BinaryInfC{$\Gamma, x : B, \Theta \vdash C(x)\ \type$}
            \DisplayProof
        \end{center}
        
        En general, el concepto de sustituir es uno muy importante en las 
        estructuras de pensamiento humanas, por lo que es de esperarse que dicho 
        concepto también esté persente en esta teoría.

        Al tener ya una noción de igualdad, podemos comenzar a hacernos 
        preguntas sobre sustituciones de elementos en otros elementos.

        Consideremos una sección $f(x)$ de una familia de tipos $B(x)$ indizado 
        por $x : A$ en un contexto $\Gamma$. Al ser que $f(x)$ como expresión
        contiene al menos una referencia a $x$, y $f(x) : B(x)$ entonces
        al sustituir cada referencia de $x$ por algún $a : A$ de forma 
        simultánea sobre $f(x) : B(x)$ debemos esperar que $f[a/x]$ sea un
        elemento de $B[a / x]$. 

        En general, \textbf{la regla de sustitución}

        \begin{center}
            \AxiomC{$\Gamma \vdash a : A$}
            \AxiomC{$\Gamma, x : A, \Theta \vdash \mathfrak{T}$}
            \RightLabel{$a/x$}
            \BinaryInfC{$\Gamma, \Theta[a/x] \vdash \mathfrak{T}[a/x]$}
            \DisplayProof
        \end{center}

        también nos permite sustituir de forma simultánea sobre un contexto dado.
        Es importante mencionar que el orden de los elementos en un contexto es
        escencial, pues $\Gamma, x : A, \Theta$ no es lo mismo que 
        $\Gamma, \Theta, x : A$. El orden es indicativo de cierta potencial
        dependencia entre elementos del contexto.

        Por ejemplo, si

        $$
        \Gamma, x : A, s : S, m : M \vdash C(x)\ type
        $$

        entonces por la regla de sustitución, dado $\Gamma \vdash a : A$ 
        tendríamos

        $$
        \Gamma, s : S[a/x], m : M[a/x] \vdash C[a/x]\ type
        $$

        donde potencialmente los tipos de $s, m$ sean distintos. 
        Por otro lado si

        $$
        \Gamma, s : S, m : M, x : A \vdash C(x)\ type
        $$

        entonces la regla de sustitución sólo nos permite asegurar que

        $$
        \Gamma, s : S, m : M \vdash C[a/x]\ type
        $$

        y los tipos de $s$ y $m$ no sufren cambios.

        Es de esperarse que, si se tiene que dos elementos son juiciosamente
        iguales, entonces la sustitución respeta esta igualdad juiciosa.

        \begin{center}
            \AxiomC{$\Gamma \vdash a \equiv a' : A$}
            \AxiomC{$\Gamma, x : A, \Delta \vdash B\ \type$}
            \BinaryInfC{$\Gamma, \Delta[a/x] \vdash B[a/x] \equiv B[a'/x]$}
            \DisplayProof
        \end{center}

        \begin{center}
            \AxiomC{$\Gamma \vdash a \equiv a' : A$}
            \AxiomC{$\Gamma, x : A, \Delta \vdash b : B\ \type$}
            \RightLabel{$[a/x]$-cong}
            \BinaryInfC{$\Gamma, \Delta[a/x] \vdash b[a/x] \equiv b[a'/x] : B[a/x]$}
            \DisplayProof
        \end{center}

        \begin{notation}\hfill
            \begin{itemize}
                \item A partir de este momento acordamos en denotar a $b[x/a]$ por simplemente
                $b(a)$, y a $B[x/a]$ por $B(a)$ a menos que sea necesario emplear la
                notación usual de sustitución.
                \item La regla también se denotar\'a por \textit{S-cong} o simplemente \textit{cong} para aligerar
                la notación cuando sea necesario.
            \end{itemize}
        \end{notation}

        
        
        Consideremos la siguente regla

        \begin{center}
            \AxiomC{$\Gamma \vdash A\ \type$}
            \AxiomC{$\Gamma, \Theta \vdash \mathfrak{T}$}
            \RightLabel{W}
            \BinaryInfC{$\Gamma, x  : A, \Theta \vdash \mathfrak{T}$}
            \DisplayProof
        \end{center}

        A primer vistazo parece ser que la regla nos quiere decir que si podemos 
        derivar una tesis de juicio $\mathfrak{T}$ desde un contexto $\Gamma$, 
        entonces al introducir una variable no presente en $\mathfrak{T}$ ni en 
        $\Gamma$ (una variable libre) podamos deducir exactamente lo mismo. 

        Sin embargo esta no es toda la historia. Una pregunta natural que surge
        es \textit{¿qué ocurre con la nueva dependencia agregada sobre la 
        variable $x: A$?}. Por ejemplo, consideremos que desde un contexto
        $\Gamma$ podemos deducir que $A\ \type$ y $B\ \type$. ¡Entonces la regla
        anterior nos dice que podemos deducir que $B$ es una familia sobre $A$!

        \begin{center}
            \AxiomC{$\Gamma \vdash A\ \type$}
            \AxiomC{$\Gamma \vdash B\ \type$}
            \BinaryInfC{$\Gamma, x : A \vdash B\ \type$}
            \DisplayProof
        \end{center}

        En tanto que estamos agregando hipótesis adicionales a una derivación,
        decimos que estamos \textit{debilitando} la conclusión. De ahí que el
        nombre de la regla sea \textbf{\textit{weakening}} o 
        \textbf{\textit{regla de debilitamiento}}. Identificamos esta regla en
        un árbol de derivación por la letra $W$.

        La \textbf{regla de introducción de variables}, o también conocida como
        \textbf{regla del elemento genérico}, es un caso particular de la regla 
        de debilitamiento, en tanto que si la tesis de juicio es $A\ \type$ y 
        $\Theta$ es vacío, entonces podemos derivar

        \begin{center}
            \AxiomC{$\Gamma \vdash A\ \type$}
            \RightLabel{VAR}
            \UnaryInfC{$\Gamma, x : A \vdash x : A$}
            \DisplayProof
        \end{center}

        Como ejemplos de derivaciones se presentan a continuación algunas
        reglas derivables útiles desde las reglas discutidas anteriormente:

        \begin{theorem}[sustitución de variables por otras]\label{teo:sust_var_teo}\hfill\newline
            Sean $\Gamma$ y $\Theta$ contextos y $\mathfrak{T}$ una tesis de
            juicio tales que 
            $$
                \Gamma, x : A, \Theta \vdash \mathfrak{T}
            $$

            Entonces se puede deducir que

            $$
                \Gamma, x' : A, \Theta[x'/x] \vdash \mathfrak{T}[x/x']
            $$
        \end{theorem}
        \begin{proof}\hfill\newline
            \begin{center}
                \AxiomC{$\Gamma \vdash A\ \type$}
                \AxiomC{$\Gamma, x : A, \Theta \vdash \mathfrak{T}$}
                \RightLabel{W}
                \BinaryInfC{$\Gamma, x' : A, x : A, \Theta \vdash \mathfrak{T}$}
                    \AxiomC{$\Gamma \vdash A\ \type$}
                    \RightLabel{VAR}
                    \UnaryInfC{$\Gamma, x' : A \vdash x' : A$}
                \BinaryInfC{$\Gamma, x' : A, \Theta[x'/x] \vdash \mathfrak{T}[x/x']$}
                \DisplayProof
            \end{center}
        \end{proof}

        \begin{theorem}[regla de intercambio del orden de variables]
            \hfill\newline
            \begin{center}
                \AxiomC{$\Gamma, x : A, y : B, \Theta \vdash \mathfrak{T}$}
                \UnaryInfC{$\Gamma, y : B, x : A, \Theta \vdash \mathfrak{T}$}
                \DisplayProof
            \end{center}
        \end{theorem}
        \begin{proof}\hfill\newline
            Notemos que por el teorema \ref{teo:sust_var_teo} tenemos que
            de $\Gamma, x : A, y : B, \Theta \vdash \mathfrak{T}$ podemos
            deducir 
            $$\Gamma[y'/y], x : A, y' : B, \Theta[y'/y] \vdash \mathfrak{T}[y/y']$$

            La idea ahora es agregar $y : B$ de vuelta al árbol de derivación
            y sustituir adecuadamente para obtener la tesis de juicio deseada.
            \begin{center}
                    \AxiomC{$\Gamma, x : A, y : B, \Theta \vdash \mathfrak{T}$}
                    \UnaryInfC{$\Gamma[y'/y], x : A, y' : B, \Theta[y'/y] \vdash \mathfrak{T}[y/y']$}
                        \AxiomC{$\Gamma \vdash B\ \type$}
                    \LeftLabel{W}
                    \BinaryInfC{$\Gamma[y'/y], y : B, x : A, y' : B, \Theta[y'/y] \vdash \mathfrak{T}[y/y']$}

                \AxiomC{$\Gamma \vdash B\ \type$}
                \RightLabel{VAR}
                \UnaryInfC{$\Gamma, y : B \vdash y : B$}
                    \AxiomC{$\Gamma \vdash A\ \type$}
                \RightLabel{W}
                \BinaryInfC{$\Gamma, y : B, x : A \vdash y : B$}
                \RightLabel{$[y/y']$}
                \BinaryInfC{$\Gamma, y : B, x : A, \Theta \vdash \mathfrak{T}$}
                \DisplayProof
            \end{center}
        \end{proof}

        \begin{theorem}[relga de conversión de elementos]
            \hfill\newline
            \begin{center}
                \AxiomC{$\Gamma \vdash A \equiv A'\ \type$}    
                \AxiomC{$\Gamma \vdash a : A$}
                \BinaryInfC{$\Gamma \vdash a : A'$}
                \DisplayProof
            \end{center}
        \end{theorem}
        \begin{proof}\hfill\newline
            \begin{center}
                \AxiomC{$\Gamma \vdash A \equiv A'\ \type$}
                \UnaryInfC{$\Gamma \vdash A'\ \type$}
                \LeftLabel{VAR}
                \UnaryInfC{$\Gamma, x' : A \vdash x : A'$}
                    \AxiomC{$\Gamma \vdash A \equiv A'\ \type$}
                \LeftLabel{ConvVar}
                \BinaryInfC{$\Gamma, x : A \vdash x : A'$}
                    \AxiomC{$\Gamma, x : A \vdash a : A$}
                \RightLabel{[$a/x$]}
                \BinaryInfC{$\Gamma \vdash a : A'$}
                \DisplayProof
            \end{center}
            
        \end{proof}

        \begin{theorem}[regla de congruencia para la conversión de elementos]
            \hfill\newline
            \begin{center}
                \AxiomC{$\Gamma \vdash A \equiv A'\ \type$}
                \AxiomC{$\Gamma \vdash a \equiv b : A$}
                \BinaryInfC{$\Gamma \vdash a \equiv b : A'$}
                \DisplayProof
            \end{center}
        \end{theorem}

        \begin{proof}
            \hfill\newline\todo{Aqui no pude simplemente haber aplicado el teorema anterior??? Son la misma prueba!}
            \begin{center}
                \AxiomC{$\Gamma \vdash A \equiv A'\ \type$}
                \UnaryInfC{$\Gamma \vdash A'\ \type$}
                \RightLabel{VAR}
                \UnaryInfC{$\Gamma, x : A' \vdash x : A'$}
                    \AxiomC{$\Gamma \vdash A \equiv A'$}
                \RightLabel{ConvVar}
                \BinaryInfC{$\Gamma, x : A \vdash x : A'$}
                    \AxiomC{$\Gamma \vdash a \equiv b : A$}
                \RightLabel{$[a \equiv b / x]$}
                \BinaryInfC{$\Gamma \vdash a \equiv b : A'$}
                \DisplayProof
            \end{center}
            Lo otro que se me ocurre es probar que por separado $a : A'$ y $b : A'$
            y entonces como $a \equiv b : A$ y por separado son también de tipo $A'$
            entonces $a \equiv b : A'$. Sin embargo, desconozco qué regla podría usar
            para unir a estas dos letras en una equivalencia :(
            \begin{center}
                \AxiomC{$\Gamma \vdash a \equiv b : A$}
                \UnaryInfC{$\Gamma \vdash a : A$}
                    \AxiomC{$\Gamma \vdash A \equiv A'\ \type$}
                \RightLabel{teo 5.2}
                \BinaryInfC{$\Gamma \vdash a : A'$}

                    \AxiomC{$\Gamma \vdash a \equiv b : A$}
                    \UnaryInfC{$\Gamma \vdash b : A$}
                        \AxiomC{$\Gamma \vdash A \equiv A'\ \type$}
                    \RightLabel{teo 5.2}
                    \BinaryInfC{$\Gamma \vdash b : A'$}
                \RightLabel{????}
                \BinaryInfC{$\Gamma \vdash a \equiv b : A'$}
                \DisplayProof
            \end{center}
        \end{proof}

    \subsection{Tipos primitivos}
        Ya que contamos con un minimo fundamento sobre el cual poder construir
        tipos, procedemos a discutir sobre aquellos tipos que el sistema
        permite construir desde un contexto vacío. Estos tipos formarán los
        bloques básicos sobre los que haremos las construcciones de nuevos
        tipos y más aún, serán de gran utilidad para comenzar a darnos una idea
        de cómo codificar objetos matemáticos en este lenguaje.
    \subsubsection{Funciones dependientes}
    \todo{Poner codigo en agda de esto}
        Una función dependiente podemos pensarla como aquella tal que permite
        que el codominio varíe en función de un elemento del dominio. En
        la teoría de conjuntos se presenta una construcción semejante, y es la
        del producto generalizado. Recordando, el producto generalizado de una
        familia indizada es
        $$
            \prod_{i \in \Gamma} X_i := 
            \{f : \Gamma \rightarrow \bigcup\limits_{i \in \Gamma} X_i\ 
                \vert\ \forall i \in \Gamma\ f(i) \in X_i\}
        $$

        de modo que un elemento $f$ del producto cartesiano es una función que
        dibuja una serie de posibilidades para el valor que puede tomar 
        $f(i) \in X_i$. Esta misma situación se nos presentó al introducir las
        familias de tipos,
        $$
            \mathrm{Ctx}, i : \Gamma \vdash X(i)\ \type
        $$
        $$
            \mathrm{Ctx}, i : \Gamma \vdash f(i) : X(i)
        $$
        de modo que $f : X$ es una función dependiente. Este tipo tiene 
        distintos nombres en la literatura: \textbf{tipo $\Pi$}, 
        \textbf{el producto cartesiano de una familia de tipos} y 
        \textbf{el tipo de funciones dependientes}.
        \begin{definition}[tipo de funciones dependientes]
            La \textbf{regla de formación} del tipo de funciones dependientes 
            establece que la existencia de una familia de tipos es suficiente
            para obtener un tipo de funciones dependientes:\hfill
            \hfill\newline\textbf{Regla de formación}\hfill\newline
            \begin{center}
                \AxiomC{$\Gamma, x : A \vdash B(x)\ \type$}
                \RightLabel{$\Pi$}
                \UnaryInfC{$\Gamma \vdash \prod_{(x : A)}B(x)\ \type$}
                \DisplayProof
            \end{center}
            Además, la formación del tipo producto es congruente con la igualdad
            juiciosa, esto es,
            \begin{center}
                \AxiomC{$\Gamma \vdash A \equiv A'\ \type$}
                \AxiomC{$\Gamma x : A \vdash B(x) \equiv B'(x)\ \type$}
                \RightLabel{$\Pi$-eq}
                \BinaryInfC{$\Gamma \vdash \prod_{(x: A)} B(x)\ \type 
                    \equiv \prod_{(x:A')}B(x)\ \type$}
                \DisplayProof
            \end{center}

            La \textbf{regla de introducción} establece que los elementos del
            tipo de funciones dependientes son exactamente las funciones que
            asignan a un término "índice" de la familia a una función.
            \hfill\newline\textbf{Regla de introducción}\hfill\newline
            \begin{center}
                \AxiomC{$\Gamma, x : A \vdash b(x):B(x)$}
                \RightLabel{$\lambda$}
                \UnaryInfC{$\Gamma \vdash \lambda x\ .\ b(x) : B(x)$}
                \DisplayProof
            \end{center}
            Más aún, postulamos la congruencia de esta regla ante la igualdad
            juiciosa:
            \begin{center}
                \AxiomC{$\Gamma, x : A \vdash b(x) \equiv b'(x) : B(x)$}
                \RightLabel{$\lambda$-eq}
                \UnaryInfC{$\Gamma \vdash \lambda x\ .\ b(x) \equiv \lambda x\ .\ b'(x) : \prod_{(x : A)} B(x)$}
                \DisplayProof
            \end{center}

            La \textbf{regla de eliminación} del tipo de funciones dependientes,
            como es de esperarse, nos permite eliminar de un árbol de deducción
            un término del tipo de funciones dependientes siempre y cuando
            podamos evaluarlo para obtener un término del tipo resultante:
            \hfill\newline\textbf{Regla de eliminación}\hfill\newline
            \begin{center}
                \AxiomC{$\Gamma \vdash f : \prod_{(x : A)} B(x)$}
                \RightLabel{ev}
                \UnaryInfC{$\Gamma, x : A \vdash f(x) : B(x)$}
                \DisplayProof
            \end{center}

            La \textbf{regla de cómputo} del tipo de funciones dependientes
            postula que la evaluación de un término de $\prod_{(x : A)} B(x)$ es
            simplemente evaluar el término dado en $A$ en $b(x) : B(x)$,
            semejante a la reducción $\beta$ del cálculo lambda:
            \hfill\newline\textbf{Regla de c\'{o}mputo}\hfill\newline
            \begin{center}
                \AxiomC{$\Gamma, x : A\vdash b(x) : B(x)$}
                \RightLabel{$\beta$}
                \UnaryInfC{$\Gamma, x : A \vdash (\lambda y\ .\ b(y))(x) \equiv b(x) : B(x)$}
                \DisplayProof
            \end{center}

            Por otro lado, \textbf{la regla $\eta$} o también conocida como
            \textbf{regla/postulado de unicidad} nos asegura que los elementos 
            de un tipo de funciones dependientes son exactamente funciones.
            \begin{center}
                \AxiomC{$\Gamma \vdash b : \prod_{(x : A)} B(x)$}
                \RightLabel{$\eta$}
                \UnaryInfC{$\Gamma \vdash \lambda x\ .\ b(x) \equiv b : \prod_{(x : A)} B(x)$}
                \DisplayProof
            \end{center}
        \end{definition}

        \begin{remark}
            Análogamente a su simíl en conjuntos, una familia de tipos involucra
            una elección, en este caso de un $b(x) : B(x)$ dado un $x : A$.
        \end{remark}
        \begin{remark}
            Observe que la regla de cómputo y la regla $\eta$ son inversas 
            mutuas.
        \end{remark}

        Observe que, si tratamos con una familia de tipos constante; esto es que
        el tipo codominio no varia según el término índice; tenemos una función.
        Las reglas que definen al tipo de funciones dependientes se simplifican
        entonces:
        \begin{center}
            \AxiomC{$\Gamma \vdash A\ \type$}
            \AxiomC{$\Gamma \vdash B\ \type$}
            \RightLabel{(weakening)}
            \BinaryInfC{$\Gamma, x : A \vdash B\ \type$}
            \UnaryInfC{$\Gamma \vdash \prod_{(x : A)} B\ \type$}
            \DisplayProof
        \end{center}
        De modo que, ante una situación como la anterior la regla de 
        introducción nos diría que las funciones son exactamente las
        abstracciones lambdas sobre un tipo en función de un término:
        \begin{center}
            \AxiomC{$\Gamma, x : A \vdash b(x) : B$}
            \UnaryInfC{$\Gamma \vdash \lambda x\ .\ b(x) : \prod_{(x : A)} B$}
            \DisplayProof
        \end{center}

        La regla de eliminación nos dice exactamente lo que esperaríamos de un
        tipo que codifica una función:
        \begin{center}
            \AxiomC{$\Gamma \vdash f : \prod_{(x : A)} B$}
            \UnaryInfC{$\Gamma, x : A \vdash f(x) : B$}
            \DisplayProof
        \end{center}
        Si evaluamos una función $f$ con dominio en $A$ y codominio en $B$ en un
        elemento $x : A$ del dominio, entonces $f(x) : B$.

        Así, mediante una regla de derivación consolidamos nuestra definición
        del tipo de funciones o equivalentemente llamado tipo flecha:
        
        \begin{definition}[tipo de funciones]
            El tipo de funciones de un tipo $A$ en un tipo $B$ se define como
            a continuación:
            \begin{center}
                \AxiomC{$\Gamma \vdash A\ \type$}
                \AxiomC{$\Gamma \vdash B\ \type$}
                \BinaryInfC{$\Gamma, x : A \vdash B\ \type$}
                \UnaryInfC{$\Gamma \vdash \prod_{(x : A)} B\ \type$}
                \UnaryInfC{$\Gamma \vdash A \rightarrow B := \prod_{(x : A)} B\ \type$}
                \DisplayProof
            \end{center}
        
            En algunas ocasiones emplearemos la notación $B^A$ para denotar
            $A \rightarrow B$. Esto es, $B^A$ dentoa el tipo de funciones de $A$ en
            $B$. 
        \end{definition}
        En general, dada una construcción podemos crear una definición con base
        en el resultado final. Para ello, conveniremos en el símbolo $:=$ para
        denotar que se está realizando una definición. Como es de esperarse,
        las mismas reglas que aplicaban para el tipo de funciones dependientes
        aplican para nuestra definición del tipo de funciones:

        \begin{center}
            \AxiomC{$\Gamma \vdash A\ \type$}
            \AxiomC{$\Gamma \vdash B\ \type$}
            \RightLabel{$\rightarrow$}
            \BinaryInfC{$\Gamma \vdash A \rightarrow B\ \type$}
            \DisplayProof
            \hskip 1.5 em
            \AxiomC{$\Gamma, x : A \vdash f(x) : B$}
            \RightLabel{$\lambda$}
            \UnaryInfC{$\Gamma \vdash \lambda\ x\ .\ f(x) : A \rightarrow B$}
            \DisplayProof
        \end{center}
        \begin{center}
            \AxiomC{$\Gamma \vdash A \equiv A'\ \type$}
            \AxiomC{$\Gamma \vdash B \equiv B'\ \type$}
            \RightLabel{$\rightarrow$-eq}
            \BinaryInfC{$\Gamma \vdash A \rightarrow B \equiv A' \rightarrow B'\ \type$}
            \DisplayProof
        \end{center}
        \begin{center}
            \AxiomC{$\Gamma, x : A \vdash b(x) \equiv b'(x) : B$}
            \RightLabel{$\lambda$-eq}
            \UnaryInfC{$\Gamma \vdash \lambda x\ .\ b(x) \equiv \lambda x\ .\ b'(x) : A \rightarrow B$}
            \DisplayProof
        \end{center}
        \begin{center}
            \AxiomC{$\Gamma \vdash f: A \rightarrow B$}
            \RightLabel{ev}
            \UnaryInfC{$\Gamma, x : A \vdash f(x) : B$}
            \DisplayProof
            \hskip 1.5 em
            \AxiomC{$\Gamma \vdash f \equiv g : A \rightarrow B$}
            \RightLabel{ev-eq}
            \UnaryInfC{$\Gamma, x : A \vdash f(x) \equiv g(x) : B$}
            \DisplayProof
        \end{center}
        \begin{center}
            \AxiomC{$\Gamma \vdash f : A \rightarrow B$}
            \RightLabel{$\eta$}
            \UnaryInfC{$\Gamma \vdash \lambda x\ .\ f(x) \equiv f : A \rightarrow B$}
            \DisplayProof
            \hskip 1.5em
            \AxiomC{$\Gamma \vdash B\ \type$}
            \AxiomC{$\Gamma, y : A \vdash f(a) : B$}
            \RightLabel{$\beta$}
            \BinaryInfC{$\Gamma, y : A \vdash (\lambda\ x\ .\ f(x))(y) \equiv f(y) : B$}
            \DisplayProof
        \end{center}
    \todo{Poner la implementación en agda de esto}
    
    \begin{remark}
        Observe que dados dos tipos $A$ y $B$ podemos obtener una función
        genérica de $A$ en $B$ y evaluarla.
        \begin{center}
            \AxiomC{$\Gamma \vdash A\ \type$}
            \AxiomC{$\Gamma \vdash B\ \type$}
            \RightLabel{$\rightarrow$}
            \BinaryInfC{$\Gamma \vdash A \rightarrow B\ \type$}
            \RightLabel{VAR}
            \UnaryInfC{$\Gamma, f : A \rightarrow B \vdash f : A \rightarrow B$}
            \RightLabel{ev}
            \UnaryInfC{$\Gamma, f : A \rightarrow B, x : A \vdash f(x) : B$}
            \DisplayProof
        \end{center}
    \end{remark}

    \todo{Poner la prueba en agda de esto tambien}

    El siguiente lema nos permitirá simplificar las demostraciones al abstraer
    el proceso de evaluación de un término de un tipo flecha en un elemento de
    su dominio.
    \begin{lemma}\label{lemma:eval-fun}\hfill
        \begin{center}
            \AxiomC{$\Gamma \vdash f : \prod_{(x : A)} B(x)$}
                \AxiomC{$\Gamma \vdash a : A$}
            \BinaryInfC{$\Gamma \vdash f(a) : B(a)$}
            \DisplayProof
        \end{center}
    \end{lemma}
    \begin{proof}\hfill
        \begin{center}
            \AxiomC{$\Gamma \vdash f : \prod_{(x : A)} B(x)$}
            \RightLabel{ev}
            \UnaryInfC{$\Gamma, x : A \vdash f(x) : B(x)$}
                \AxiomC{$\Gamma \vdash a : A$}
                \RightLabel{W}
                \UnaryInfC{$\Gamma, x : A \vdash a : A$}
            \RightLabel{$a/x$}
            \BinaryInfC{$\Gamma, x : A \vdash f(a) : B(a)$}
            \DisplayProof
        \end{center}
    \end{proof}

    \begin{corollary}\hfill
        \begin{center}
            \AxiomC{$\Gamma \vdash f : A \rightarrow B$}
            \AxiomC{$\Gamma \vdash a : A$}
            \BinaryInfC{$\Gamma \vdash f(a) : B$}
            \DisplayProof
        \end{center}
    \end{corollary}

    \begin{theorem}[Extensionalidad bajo la igualdad de juicio]
        \hfill
        \begin{center}
            \AxiomC{$\Gamma \vdash f : \prod_{(x : A)} B(x)$}
            \AxiomC{$\Gamma \vdash g : \prod_{(x : A)} B(x)$}
            \AxiomC{$\Gamma, x : A \vdash f(x) \equiv g(x) : B(x)$}
            \TrinaryInfC{$\Gamma \vdash f \equiv g : \prod_{(x : A)} B(x)$}
            \DisplayProof
        \end{center}
    \end{theorem}
    \begin{proof}\hfill\newline
        {\scriptsize
        \begin{center}
            \AxiomC{$\Gamma, x : A \vdash f(x) \equiv g(x) : B(x)$} 
            \LeftLabel{$\lambda$-eq}
            \UnaryInfC{$\Gamma \vdash \lambda x\ .\ f(x) \equiv \lambda x\ .\ g(x) : \prod_{(x : A)} B(x)$}
                \AxiomC{$\Gamma \vdash f : \prod_{(x : A)} B(x)$}
                \RightLabel{$\eta$}
                \UnaryInfC{$\Gamma \vdash \lambda x\ .\ f(x) \equiv f : \prod_{(x : A)} B(x)$}
            \LeftLabel{$\equiv$-trans}
            \BinaryInfC{$\Gamma \vdash \lambda x\ .\ f(x) \equiv g : \prod_{(x : A)} B(x)$}
                \AxiomC{$\Gamma \vdash g : \prod_{(x : A)} B(x)$}
                \RightLabel{$\eta$}
                \UnaryInfC{$\Gamma \vdash \lambda x\ .\ g(x) \equiv g : \prod_{(x : A)} B(x)$}
            \BinaryInfC{$\Gamma \vdash f \equiv g : \prod_{(x : A)} B(x)$}
            \DisplayProof    
        \end{center}
        }
    \end{proof}

    \begin{corollary}[Extensionalidad bajo la igualdad de juicio]
        \label{coro:extensionalidad-juicio-flecha}
        \hfill
        \begin{center}
            \AxiomC{$\Gamma \vdash f : B^A$}
            \AxiomC{$\Gamma \vdash g : B^A$}
            \AxiomC{$\Gamma, x : A \vdash f(x) \equiv g(x) : B(x)$}
            \TrinaryInfC{$\Gamma \vdash f \equiv g : B^A$}
            \DisplayProof
        \end{center}
    \end{corollary}

    %%% TODO: Poner la implementación en agda de esto
    
    Para terminar con esta subsección se presentan a continuación algunas
    construcciones útiles con tipos flecha.
    \subsubsection*{Algunas construcciones útiles con el tipo flecha}
    \textbf{La flecha identidad.}\newline
    Deseamos definir un objeto que codifique a la flecha identidad. Sabemos que
    la flecha identidad es tal que para todo objeto perteneciente al dominio se
    corresponde a si mismo bajo esta flecha. En general, algo a observar de lo
    anterior es que en principio el dominio y contradominio de la flecha
    identidad puede ser el que sea mientras exista. De esta forma, comenzamos
    nuestra construcción postulando que de tener un tipo en algún contexto
    podemos entonces construir este objeto.
    $$
        \Gamma \vdash A\ \type
    $$
    Luego, aplicando la regla de introducción de variables podemos obtener de
    lo anterior lo siguiente:
    \begin{center}
        \AxiomC{$\Gamma \vdash A\ \type$}
        \UnaryInfC{$\Gamma, x : A \vdash x : A$}
        \DisplayProof
    \end{center}
    Por la conclusión anterior, podemos entonces aplicar la regla de 
    introducción del tipo flecha:
    \begin{center}
        \AxiomC{$\Gamma \vdash A\ \type$}
        \RightLabel{VAR}
        \UnaryInfC{$\Gamma, x : A \vdash x : A$}
        \RightLabel{$\lambda$}
        \UnaryInfC{$\Gamma \vdash \lambda\ x\ .\ x : A \rightarrow A$}
        \DisplayProof
    \end{center}
    Para así poder concluir nuestra definición:
    \begin{center}
        \AxiomC{$\Gamma \vdash A\ \type$}
        \RightLabel{VAR}
        \UnaryInfC{$\Gamma, x : A \vdash x : A$}
        \RightLabel{$\lambda$}
        \UnaryInfC{$\Gamma \vdash \lambda\ x\ .\ x : A \rightarrow A$}
        \UnaryInfC{$\Gamma \vdash \Id_A := \lambda\ x\ .\ x : A \rightarrow A$}
        \DisplayProof
    \end{center}

    Claramente nuestra flecha identidad debe satisfacer que todo elemento
    evaluado en dicha flecha es (juiciosamente) equivalente a si mismo.

    \begin{lemma}\hfill\newline
        \begin{center}
            \AxiomC{$\Gamma \vdash A\ \type$}
            \UnaryInfC{$\Gamma, x : A \vdash \Id_A(x) \equiv x$}
            \DisplayProof
        \end{center}
    \end{lemma}
    \begin{proof}\hfill\newline
        \begin{center}
            \AxiomC{$\Gamma \vdash A\ \type$}
            \UnaryInfC{$\Gamma \vdash \Id_A : A \rightarrow A$}
            \UnaryInfC{$\Gamma \vdash \Id_A \equiv \lambda\ y.\ y : A \rightarrow A$}
            \RightLabel{$\rightarrow$-ev}
            \UnaryInfC{$\Gamma, x : A \vdash \Id_A(x) \equiv (\lambda\ y\ .\ y)(x) : A$}
            \RightLabel{$\beta$}
            \UnaryInfC{$\Gamma, x : A \vdash \Id_A(x) \equiv x : A$}
            \DisplayProof    
        \end{center}
    \end{proof}
    \textbf{Tomando múltiples argumentos}\newline\newline
    Ciertamente pareciera que nuestro tratamiento sobre el tipo flecha tiene la
    limitante sobre el número de argumentos que puede tomar una función. En las
    matemáticas que conocemos es común observar funciones que requiere de más de
    una entrada, como por ejemplo la suma aritmética entre dos números
    naturales. Sin embargo, el tratamiento dado sobre los elementos del tipo
    $\Pi$ nos permite expresar esta clase de funciones. Para demostrarlo,
    consideremos el caso de la suma de dos números naturales:
    $$
        +_{\mathbb{N}} : \mathbb{N} \times \mathbb{N} \rightarrow \mathbb{N}
    $$
    Notemos que si proporcionamos un número natural $n \in \mathbb{N}$ y lo 
    aplicamos como entrada a la función suma, estamos ante la situación en
    donde cualquier otro número natural $m \in \mathbb{N}$ al ser aplicado como
    entrada a la función (manteniendo fijo a $n$) nos da como resultado la suma
    de la nueva entrada $m$ con $n$. Es decir, podemos pensar que al aplicar un
    solo argumento a la función, restringimos las entradas a un grado de
    libertad menor, que es lo mismo que decir que estamos ante una nueva función
    que, para este caso particular, toma un argumento menos.
    \begin{align*}
        +_{n} : \mathbb{N} &\rightarrow \mathbb{N}\\
        m &\mapsto m +_{\mathbb{N}} n
    \end{align*}
    Esta perspectiva entonces pareciera sugerir que las funciones que toman más
    de dos parámetros son simplemente funciones que toman un argumento y 
    regresan una función que toma el siguiente argumento y así de forma
    sucesiva hasta llegar al resultado final.
    \begin{align*}
        +_\mathbb{N} : \mathbb{N} &\rightarrow (\mathbb{N} \rightarrow \mathbb{N})\\
        n &\mapsto +_n : \mathbb{N} \rightarrow \mathbb{N}
    \end{align*}
    Este proceso recibe el nombre de "currying" en honor al matemático Haskell 
    Curry, a pesar de que fueron Frege y Schönfinkel quienes originalmente 
    concibieron la idea.\footnote{Ver \cite{schonfinkel} y \cite{frege}
    para más información sobre sus origenes.}

    De manera semejante, si $C(x,y)$ es una familia de tipos indizada por dos
    elementos $x : A$ y $y : B$, entonces podemos formar el tipo
    \begin{center}
        \AxiomC{$\Gamma, y : B \vdash \prod_{(y : B)}C(x,y)\ \type$}
        \RightLabel{$\Pi$}
        \UnaryInfC{$\Gamma, x : A \vdash \prod_{(y : B)}C(x,y)\ \type$}
        \RightLabel{$\Pi$}
        \UnaryInfC{$\prod_{(x : A)}\prod_{(y : B)}C(x,y)\ \type$}
        \DisplayProof
    \end{center}
    Queda pendiente demostrar que efectivamente esta perspectiva es correcta.
    \begin{theorem}[Currying]
        
    \end{theorem}
    \textbf{La composición de flechas.}\newline
    Consideremos tres tipos en un contexto $\Gamma$, $A$, $B$ y $C$. Gracias a
    la regla de debilitamiento de los tres tipos podemos obtener al menos dos
    funciones genéricas: $A \rightarrow B$ y $B \rightarrow C$, un elemento
    de $B$ y un elemento de $C$.
    \begin{center}
        \AxiomC{$\Gamma \vdash A\ \type$}
        \AxiomC{$\Gamma \vdash B\ \type$}
        \RightLabel{$\rightarrow$}
        \BinaryInfC{$\Gamma \vdash A \rightarrow B\ \type$}
        \RightLabel{VAR}
        \UnaryInfC{$\Gamma, f : A \rightarrow B \vdash f : A \rightarrow B$}
        \RightLabel{ev}
        \UnaryInfC{$\Gamma, f : A \rightarrow B, x : A \vdash f(x) : B$}
        \DisplayProof
        \hskip 1.5em
        \AxiomC{$\Gamma \vdash B\ \type$}
        \AxiomC{$\Gamma \vdash C\ \type$}
        \RightLabel{$\rightarrow$}
        \BinaryInfC{$\Gamma \vdash B \rightarrow C\ \type$}
        \RightLabel{VAR}
        \UnaryInfC{$\Gamma, g : B \rightarrow C \vdash g : B \rightarrow C$}
        \RightLabel{ev}
        \UnaryInfC{$\Gamma, g : B \rightarrow C, y : B \vdash g(y) : C$}
        \DisplayProof
    \end{center}
    En virtud de lo anterior, omitimos en el árbol de deducción estos pasos.
    Luego, como podemos evaluar funciones genéricas en elementos y contamos con 
    uno, podemos obtener un elemento de $C$.
    {\small
    \begin{center}
        \AxiomC{$\Gamma \vdash A\ \type$}
        \AxiomC{$\Gamma \vdash B\ \type$}
        \BinaryInfC{$\Gamma \vdash B^A\ \type$}
        \UnaryInfC{$\Gamma, f : B^A \vdash f : B^A$}
        \UnaryInfC{$\Gamma, f : B^A, x : A \vdash f(x) : B$}
        %\LeftLabel{W}
        \UnaryInfC{$\Gamma, f : B^A, x : A, g : B^A \vdash f(x) : B$}
        \DisplayProof
        \hskip 1.5em
        \AxiomC{$\Gamma \vdash B\ \type$}
        \AxiomC{$\Gamma \vdash C\ \type$}
        \BinaryInfC{$\Gamma \vdash B \rightarrow C\ \type$}
        \UnaryInfC{$\Gamma, g : B \rightarrow C \vdash g : B \rightarrow C$}
        \UnaryInfC{$\Gamma, g : B \rightarrow C, y : B \vdash g(y) : C$}
        \UnaryInfC{$\Gamma, g : C^B, f : B^A, y : B \vdash g(y) : C$}
        \UnaryInfC{$\Gamma, g : C^B, f : B^A, y : B, x : A \vdash g(y) : C$}
        \DisplayProof
    \end{center}
    }
    Por sustitución de $f(x)$ sobre $y$ obtenemos $g(f(x)) : C$. Luego,
    aplicando nuestro lema \ref{lemma:eval-fun} podemos deducir
    $$
        \Gamma, g : C^B, f : B^A, x : A \vdash g(f(x)) : C
    $$
    %\begin{remark}
    %    Observe que lo anterior fue necesario para aplicar la regla de
    %    sustitución. En efecto, en este caso
    %    \begin{align*}
    %        &\hat{\Gamma} := \{\Gamma, f : B^A, x : A, g : C^B \}\\
    %        &\mathfrak{J} := g(y) : C\\
    %        &\Delta = \varnothing
    %    \end{align*}
    %    de modo que
    %    \begin{center}
    %        \AxiomC{$\hat{\Gamma} \vdash f(x):B$}
    %        \AxiomC{$\hat{\Gamma}, y : B \vdash g(y) : C$}
    %        \BinaryInfC{$\hat{\Gamma}, \Delta[f(x)/y] \vdash \mathfrak{J}[f(x)/y]$}
    %        \UnaryInfC{$\hat{\Gamma} \vdash g(f(x)) : C$}
    %        \DisplayProof
    %    \end{center}
    %\end{remark}

    \begin{center}
        \AxiomC{$\Gamma \vdash A\ \type$}
        \AxiomC{$\Gamma \vdash B\ \type$}
        \BinaryInfC{$\Gamma, f : B^A, x : A \vdash f(x) : B$}
        \UnaryInfC{$\Gamma, f : B^A, x : A, g : C^B \vdash f(x) : B$}

        \AxiomC{$\Gamma \vdash B\ \type$}
        \AxiomC{$\Gamma \vdash C\ \type$}
        \BinaryInfC{$\Gamma, g : B \rightarrow C, y : B \vdash g(y) : C$}
        \UnaryInfC{$\Gamma, g : C^B, f : B^A, y : B \vdash g(y) : C$}
        \UnaryInfC{$\Gamma, g : C^B, f : B^A, y : B, x : A \vdash g(y) : C$}
        \BinaryInfC{$\Gamma, g : C^B, f : B^A, x : A \vdash g(f(x)) : C$}
        \DisplayProof
    \end{center}

    Abstrayendo sobre $x$ obtenemos una función que nos recuerda a la
    composición de funciones.

    \begin{center}
        \AxiomC{$\Gamma \vdash A\ \type$}
        \AxiomC{$\Gamma \vdash B\ \type$}
        \BinaryInfC{$\Gamma, f : B^A, x : A \vdash f(x) : B$}
        \UnaryInfC{$\Gamma, f : B^A, x : A, g : C^B \vdash f(x) : B$}

        \AxiomC{$\Gamma \vdash B\ \type$}
        \AxiomC{$\Gamma \vdash C\ \type$}
        \BinaryInfC{$\Gamma, g : B \rightarrow C, y : B \vdash g(y) : C$}
        \UnaryInfC{$\Gamma, g : C^B, f : B^A, y : B \vdash g(y) : C$}
        \UnaryInfC{$\Gamma, g : C^B, f : B^A, y : B, x : A \vdash g(y) : C$}
        \BinaryInfC{$\Gamma, g : C^B, f : B^A, x : A \vdash g(f(x)) : C$}
        \RightLabel{$\lambda$}
        \UnaryInfC{$\Gamma, g : C^B, f : B^A \vdash \lambda x\ .\ g(f(x)) : C^A$}
        \DisplayProof
    \end{center}

    Finalmente, abstraemos sobre $f$ y $g$ para dar con un término que es
    testigo de la existencia de la composición de funciones.
    \begin{center}
        \AxiomC{$\Gamma \vdash A\ \type$}
        \AxiomC{$\Gamma \vdash B\ \type$}
        \BinaryInfC{$\Gamma, f : B^A, x : A \vdash f(x) : B$}
        \UnaryInfC{$\Gamma, f : B^A, x : A, g : C^B \vdash f(x) : B$}

        \AxiomC{$\Gamma \vdash B\ \type$}
        \AxiomC{$\Gamma \vdash C\ \type$}
        \BinaryInfC{$\Gamma, g : B \rightarrow C, y : B \vdash g(y) : C$}
        \UnaryInfC{$\Gamma, g : C^B, f : B^A, y : B \vdash g(y) : C$}
        \UnaryInfC{$\Gamma, g : C^B, f : B^A, y : B, x : A \vdash g(y) : C$}
        \BinaryInfC{$\Gamma, g : C^B, f : B^A, x : A \vdash g(f(x)) : C$}
        \UnaryInfC{$\Gamma, g : C^B, f : B^A \vdash \lambda x\ .\ g(f(x)) : C^A$}
        \RightLabel{$\lambda$}
        \UnaryInfC{$\Gamma, g : C^B \vdash \lambda f\ .\ \lambda x\ .\ g(f(x)) : B^A \rightarrow C^A$}
        \RightLabel{$\lambda$}
        \UnaryInfC{$\Gamma \vdash \lambda g\ .\ (\lambda f\ .\ \lambda x\ .\ g(f(x))) : C^B \rightarrow (B^A \rightarrow C^A)$}
        \RightLabel{$\lambda$}
        \UnaryInfC{$\Gamma \vdash \_\circ\_ := \lambda g\ .\ (\lambda f\ .\ \lambda x\ .\ g(f(x))) : C^B \rightarrow (B^A \rightarrow C^A)$}
        \DisplayProof
    \end{center}
    Es decir, dados $f : B^A, g : C^B$
    $$
        g\circ f \equiv \lambda x\ .\ g(f(x)) : C^A
    $$

    Ya que tenemos una noción de composición de funciones y una identidad para
    cada tipo, estaría muy bien mostrar que nuestra noción de composición es
    asociativa.

    \begin{theorem}[Asociatividad de la composición]
        Si de un contexto $\Gamma$ se tienen flechas $f : B^A$, $g : C^B$ y 
        $h : D^C$, entonces 
        $h \circ (g \circ f) \equiv (h \circ g) \circ f : A \rightarrow D$.
    \end{theorem}

    \begin{proof}\hfill
        \begin{center}
            \AxiomC{$\Gamma \vdash f : B^A$}
            \RightLabel{ev}
            \UnaryInfC{$\Gamma, x : A \vdash f(x) : B$}
                \AxiomC{$\Gamma \vdash g : C^B$}
                \RightLabel{ev}
                \UnaryInfC{$\Gamma, y : B \vdash g(y) : C$}
                \RightLabel{W}
                \UnaryInfC{$\Gamma, y : B, x : A \vdash g(y) : C$}
            %\LeftLabel{lemma \ref{lemma:eval-fun}}
            \BinaryInfC{$\Gamma, x : A \vdash g(f(x)) : C$}
                    \AxiomC{$\Gamma \vdash h : D^C$}
                    \RightLabel{ev}
                    \UnaryInfC{$\Gamma, z : C \vdash h(z) : D$}
                    \RightLabel{W}
                    \UnaryInfC{$\Gamma, z : C, x : A \vdash h(z) : D$}
            \RightLabel{$g(f(x))/z$}
            \BinaryInfC{$\Gamma, x : A \vdash h(g(f(x))) : D$}
            \DisplayProof
        \end{center}
        Observemos que de $\Gamma, x : A \vdash h(g(f(x))) : D$ podemos obtener 
        las siguientes derivaciones tras aplicaciones sucesivas de la definición
        de la composición:

        \begin{center}
            \AxiomC{$\Gamma, x : A \vdash h(g(f(x))) : D$}
            \RightLabel{$\equiv$-refl}
            \UnaryInfC{$\Gamma, x : A \vdash h(g(f(x))) \equiv h(g(f(x))): D$}
            \RightLabel{$\rightarrow$-eq}
            \UnaryInfC{$\Gamma \vdash \lambda x\ .\ h(g(f(x))) \equiv \lambda x\ .\ h(g(f(x))): D^A$}
            \UnaryInfC{$\Gamma \vdash \lambda x\ .\ h(g(f(x))) \equiv \lambda x\ .\ h((g \circ f)(x)) : D^A$}
            \UnaryInfC{$\Gamma \vdash \lambda x\ .\ h(g(f(x))) \equiv \lambda x\ .\ h \circ (g \circ f)(x) : D^A$}
            \DisplayProof
        \end{center}
        \begin{center}
            \AxiomC{$\Gamma, x : A \vdash h(g(f(x))) : D$}
            \RightLabel{$\equiv$-refl}
            \UnaryInfC{$\Gamma, x : A \vdash h(g(f(x))) \equiv h(g(f(x))): D$}
            \RightLabel{$\rightarrow$-eq}
            \UnaryInfC{$\Gamma \vdash \lambda x\ .\ h(g(f(x))) \equiv \lambda x\ .\ h(g(f(x))): D^A$}
            \UnaryInfC{$\Gamma \vdash \lambda x\ .\ (h\circ g)(f(x)) \equiv \lambda x\ .\ h(g(f(x))) : D^A$}
            \UnaryInfC{$\Gamma \vdash ((h\circ g)\circ f)(x) \equiv \lambda x\ .\ h(g(f(x))) : D^A$}
            \DisplayProof
        \end{center}

        De modo que, por la transitividad de $\equiv$ podemos conlcuir la 
        equivalencia que deseamos.

        \begin{center}
            \AxiomC{$\Gamma, x : A \vdash h(g(f(x))) : D$}
            \UnaryInfC{$\Gamma, x : A \vdash h(g(f(x))) \equiv h(g(f(x))): D$}
            \UnaryInfC{$\Gamma \vdash \lambda x\ .\ h(g(f(x))) \equiv \lambda x\ .\ h(g(f(x))): D^A$}
            \UnaryInfC{$\Gamma \vdash \lambda x\ .\ h(g(f(x))) \equiv \lambda x\ .\ h((g \circ f)(x)) : D^A$}
            \UnaryInfC{$\Gamma \vdash \lambda x\ .\ h(g(f(x))) \equiv \lambda x\ .\ h \circ (g \circ f)(x) : D^A$}

            \AxiomC{$\Gamma, x : A \vdash h(g(f(x))) : D$}
            \UnaryInfC{$\Gamma, x : A \vdash h(g(f(x))) \equiv h(g(f(x))): D$}
            \UnaryInfC{$\Gamma \vdash \lambda x\ .\ h(g(f(x))) \equiv \lambda x\ .\ h(g(f(x))): D^A$}
            \UnaryInfC{$\Gamma \vdash \lambda x\ .\ (h\circ g)(f(x)) \equiv \lambda x\ .\ h(g(f(x))) : D^A$}
            \UnaryInfC{$\Gamma \vdash \lambda x\ .\ ((h\circ g)\circ f)(x) \equiv \lambda x\ .\ h(g(f(x))) : D^A$}
            \BinaryInfC{$\Gamma \vdash ((h\circ g)\circ f)(x) \equiv h \circ (g \circ f)(x) : D^A$}
            \DisplayProof
        \end{center}
    \end{proof}

    \begin{theorem}
        Sea $f : A \rightarrow B$ en un contexto $\Gamma$. Entonces
        $\Id_{B} \circ f \equiv f$ y $f \circ \Id_{A} \equiv f$.
    \end{theorem}

    \begin{proof}
        Notemos que el hecho $f \in \Gamma$ implica que $A,B\ \type \in \Gamma$.
        Así,
        {\small
        \begin{center}
            \AxiomC{$\Gamma \vdash f : B^A$}
            \RightLabel{ev}
            \UnaryInfC{$\Gamma, x : A \vdash f(x) : B$}
                \AxiomC{$\Gamma \vdash B\ \type$}
                \RightLabel{lema 5.7}
                \UnaryInfC{$\Gamma, y : B \vdash \Id_B(y) \equiv y : B$}
                    \AxiomC{$\Gamma \vdash A\ \type$}
                \RightLabel{W}
                \BinaryInfC{$\Gamma, x : A, y : B \vdash \Id_B(y) \equiv y : B$}
            \RightLabel{$[f(x)/y]$}
            \BinaryInfC{$\Gamma, x : A \vdash \Id_B(f(x)) \equiv f(x) : B$}
            \RightLabel{$\lambda$-eq}
            \UnaryInfC{$\Gamma \vdash \lambda x\ .\ \Id_B(f(x)) \equiv \lambda x\ .\ f(x) : B^A$}
            \RightLabel{$\circ$-def}
            \UnaryInfC{$\Gamma \vdash \Id_B \circ f \equiv f : B^A$}
                \AxiomC{$\Gamma \vdash f : B^A$}
                \RightLabel{$\eta$}
                \UnaryInfC{$\Gamma \vdash \lambda x\ .\ f(x) \equiv f : B^A$}
            \RightLabel{$\equiv$-trans}
            \BinaryInfC{$\Gamma \vdash \Id_B \circ f \equiv f : B^A$}
            \DisplayProof    
        \end{center}
        }
        
        {\small
        \begin{center}
            \AxiomC{$\Gamma \vdash A\ \type$}
            \UnaryInfC{$\Gamma \vdash \Id_A: A^A$}
            \RightLabel{ev}
            \UnaryInfC{$\Gamma, x : A \vdash \Id_A(x) : A$}
            \RightLabel{lema 5.7}
            \UnaryInfC{$\Gamma, x : A \vdash \Id_A(x) \equiv x : A$}
            \RightLabel{W}
            \UnaryInfC{$\Gamma, y : A, x : A \vdash \Id_A(x) \equiv x : A$}

                \AxiomC{$\Gamma \vdash f : A B^A$}
                \RightLabel{ev}
                \UnaryInfC{$\Gamma, y : A \vdash f(y) : B$}
                    \AxiomC{$\Gamma \vdash A\ \type$}
                \RightLabel{W}
                \BinaryInfC{$\Gamma, y : A, x :A \vdash f(y) : B$}
            \RightLabel{$[\Id_A(x)/y]$-cong}
            \BinaryInfC{$\Gamma, x : A \vdash f(\Id_A(x)) \equiv f(x) : B$}
            \RightLabel{$\lambda$-equiv}
            \UnaryInfC{$\Gamma, x : A \vdash \lambda x . f(\Id_A(x)) \equiv \lambda x . f(x) : B^A$}
            \RightLabel{$\circ$-def}
            \UnaryInfC{$\Gamma, x : A \vdash f\circ\Id_A \equiv \lambda x . f(x) : B^A$}
                    \AxiomC{$\Gamma \vdash f : B^A$}
                    \RightLabel{$\eta$}
                    \UnaryInfC{$\Gamma \vdash \lambda x . f(x) \equiv f : B^A$}
            \RightLabel{$\equiv$-trans}
            \BinaryInfC{$\Gamma, x : A \vdash f \circ \Id_A \equiv f : B^A$}
            \DisplayProof
        \end{center}
        }
    \end{proof}

    Con ello, los tipos flecha satisfacen:
    \begin{itemize}
        \item Para cualquier tipo $A$ existe $\Id_A : A \rightarrow A$.
        \item Para cualesquiera dos tipos $A, B$ existe un término $A \rightarrow B$.
        \item Dadas dos flechas $A \rightarrow B$, $B \rightarrow C$
        existe una tercera flecha $A \rightarrow C$.
        \item Para cualesquiera flecha $f : A \rightarrow B$ se satisface 
        \begin{itemize}
            \item $f \circ \Id_A \equiv f$
            \item $\Id_B \circ f \equiv f$
        \end{itemize}
        \item Para cualesquiera tres flechas $f : A \rightarrow B, g : B \rightarrow C, h : C \rightarrow D$
        se tiene que $f\circ (g\circ h) \equiv (f \circ g) \circ h$
    \end{itemize}
    
    y así entonces tenemos

    \begin{theorem}
        La colección
        $$
            \mathbf{Type} := \{A \ \vert\ A\ \type\}
        $$
        junto con la familia de colecciones con $A, B \in \mathbf{Type}$ 
        $$
            \mathbf{Type}(A, B) := \{f \ \vert\ f : A \rightarrow B\}
        $$
        conforman una categoría con la noción de composición definida por 
        $\_\circ\_$.
    \end{theorem}

    Para concluir con esta sección se presentan las siguientes construcciones
    de funciones que serán de útilidad en secciones posteriores y algunas de
    sus propiedades.

    \textbf{La función constante}\hfill\newline
    \begin{center}
        \AxiomC{$\Gamma \vdash A\ \type$}
        \UnaryInfC{$\Gamma, y : B \vdash \const_y : A \rightarrow B$}
        \DisplayProof
    \end{center}
    {\small \textbf{Construcción}}\hfill\newline

    Una técnica común al momento de querer construir algún objeto es observar
    las dependencias que debería tener cierto objeto y claro, tener clara la
    idea del objeto que se quiere construir.
    En el caso de la función constante la idea es muy simple, por lo que resulta
    en un excelente ejemplo de la aplicación de esta técnica. 
    Partimos de un valor existente arbitrario, y queremos que nuestra función 
    constante sea tal que para cualquier otro valor que pueda tomar nuestra
    función, al valuar dicho valor en la función obtengamos el valor del que
    partimos.
    
    \begin{center}
        \AxiomC{$?$}
        \UnaryInfC{$\Gamma, y : B \vdash \lambda x\ .\ y : A \rightarrow B$}
        \DisplayProof
    \end{center}

    Por nuestras reglas de formación de tipos, sabemos que para llegar al 
    término $\lambda x\ .\ y : A \rightarrow B$ debió haber ocurrido antes
    la aplicación de la regla $\lambda$

    \begin{center}
        \AxiomC{$?$}
        \UnaryInfC{$\Gamma, y : B, x : A \vdash y : B$}
        \UnaryInfC{$\Gamma, y : B \vdash \lambda x\ .\ y : A \rightarrow B$}
        \DisplayProof
    \end{center}

    Y la presencia de $x : A$ en la tesis de juicio $\Gamma, y : B, x : A \vdash y : B$ 
    nos recuerda a la aplicación de la regla de debilitamiento sobre la tesis
    de juicio $\Gamma, y : B \vdash y : B$. Como tenemos por hipótesis 
    $\Gamma \vdash A\ \type$ podemos aplicar dicha regla sin mayor obstáculo

    \begin{center}
        \AxiomC{$?$}
        \UnaryInfC{$\Gamma, y : B \vdash y : B$}
        \AxiomC{$\Gamma \vdash A\ \type$}
        \RightLabel{W}
        \BinaryInfC{$\Gamma, y : B, x : A \vdash y : B$}
        \RightLabel{$\lambda$}
        \UnaryInfC{$\Gamma, y : B \vdash \lambda x\ .\ y : A \rightarrow B$}
        \DisplayProof
    \end{center}

    Finalmente, al partir de la existencia de algún elemento en $B$, podemos
    simplemente suponer que partimos de la existencia de $B$ en el contexto
    y con ello mediante la regla de elemento genérico obtener el juicio deseado.
    
    \begin{center}
        \AxiomC{$\Gamma \vdash B\ \type$}
        \UnaryInfC{$\Gamma, y : B \vdash y : B$}
        \AxiomC{$\Gamma \vdash A\ \type$}
        \RightLabel{W}
        \BinaryInfC{$\Gamma, y : B, x : A \vdash y : B$}
        \RightLabel{$\lambda$}
        \UnaryInfC{$\Gamma, y : B \vdash \lambda x\ .\ y : A \rightarrow B$}
        \UnaryInfC{$\Gamma, y : B \vdash \const_y \equiv \lambda x\ .\ y : A \rightarrow B$}
        \DisplayProof
    \end{center}

    \begin{remark}\label{obs:const_igualdad}\hfill\newline
        Podemos corraborar que nuestra construcción se comporta como esperamos al
        observar el resultado de evaluar $\const_y : A \rightarrow B$ en algún 
        elemento de $A$. Notemos que por definición si 
        $\Gamma, y : B \vdash \const_y : A \rightarrow B$ entonces
        $\Gamma, x : A \vdash \const_y(x) \equiv y : B$.

        En efecto,
        \begin{center}
            \AxiomC{$\Gamma, y : B \vdash \const_y : A \rightarrow B$}
            \RightLabel{ev}
            \UnaryInfC{$\Gamma, y : B, x : A \vdash \const_y(x) : B$}
            \UnaryInfC{$\Gamma, y : B, x : A \vdash \const_y(x) \equiv (\lambda z\ .\ y) (x) : B$}
            \RightLabel{$\beta$}
            \UnaryInfC{$\Gamma, y : B, x : A \vdash \const_y(x) \equiv y : B$}
            \DisplayProof
        \end{center}        
    \end{remark}
    
    {\small \textbf{Propiedades}}\hfill\newline
    \begin{lemma}\hfill\newline
        \begin{center}
            \AxiomC{$\Gamma \vdash f : A \rightarrow B$}
            \UnaryInfC{$\Gamma, c : C \vdash \const_c \circ f \equiv \const_c : A \rightarrow C$}
            \DisplayProof
        \end{center}
    \end{lemma}
    \begin{proof}\hfill\newline
        \begin{center}
            \AxiomC{$\Gamma \vdash B\ \type$}
            \UnaryInfC{$\Gamma, c : C \vdash \const_c : B \rightarrow C$}
            \RightLabel{ev}
            \UnaryInfC{$\Gamma, c : C, z : B \vdash \const_c (z) : C$}
                \AxiomC{$\Gamma \vdash A\ \type$}
            \RightLabel{W}
            \BinaryInfC{$\Gamma, c : C, z : B, x : A \vdash \const_c(z) : C$}
                    \AxiomC{$\Gamma \vdash f : A \rightarrow B$}
                    \RightLabel{ev}
                    \UnaryInfC{$\Gamma, x : A \vdash f(x) : B$}
            \BinaryInfC{$\Gamma, c : C, x : A \vdash \const_c(f(x)) : C$}
            \RightLabel{obs \ref{obs:const_igualdad}}
            \UnaryInfC{$\Gamma, c : C, x : A \vdash \const_c(f(x)) \equiv c : C$}
            \RightLabel{$\lambda$-eq}
            \UnaryInfC{$\Gamma, c : C\vdash \lambda x\ .\ \const_c(f(x)) \equiv \lambda x\ .\ c : A \rightarrow C$}
            \RightLabel{def}
            \UnaryInfC{$\Gamma, c : C\vdash \lambda x\ .\ \const_c(f(x)) \equiv \const_c : A \rightarrow C$}
            \RightLabel{def}
            \UnaryInfC{$\Gamma, c : C\vdash \lambda x\ .\ (\const_c\circ f)(x) \equiv \const_c : A \rightarrow C$}
            \RightLabel{$\eta$}
            \UnaryInfC{$\Gamma, c : C\vdash \const_c\circ f \equiv \const_c : A \rightarrow C$}
            \DisplayProof
        \end{center}
    \end{proof}

    \begin{lemma}\hfill\newline
        \begin{center}
            \AxiomC{$\Gamma \vdash A\ \type$}
            \AxiomC{$\Gamma \vdash g : B \rightarrow C$}
            \BinaryInfC{$\Gamma, b : B \vdash g \circ \const_b \equiv \const_{g(b)} : A \rightarrow C$}
            \DisplayProof
        \end{center}
    \end{lemma}

    \begin{proof}\hfill\newline
        \begin{center}
            \AxiomC{$\Gamma \vdash g : B \rightarrow C$}
            \RightLabel{ev}
            \UnaryInfC{$\Gamma, z : B \vdash g(z) : C$}
                \AxiomC{$\Gamma \vdash A\ \type$}
            \RightLabel{W}
            \BinaryInfC{$\Gamma, z : B, x : A \vdash g(z) : C$}

                \AxiomC{$\Gamma \vdash A\ \type$}
                \UnaryInfC{$\Gamma, b : B \vdash \const_b : A \rightarrow B$}
                \RightLabel{ev}
                \UnaryInfC{$\Gamma, b : B, x : A \vdash \const_b(x) : B$}
                \RightLabel{Obs \ref{obs:const_igualdad}}
                \UnaryInfC{$\Gamma, b : B, x : A \vdash \const_b(x) \equiv b : B$}
            \BinaryInfC{$\Gamma, b : B, x : A \vdash g(\const_b(x)) \equiv g(b) : C$}
            \RightLabel{$\lambda$}
            \UnaryInfC{$\Gamma, b : B \vdash \lambda x\ .\ g(\const_b(x)) \equiv \lambda x\ .\ g(b) : A \rightarrow C$}
            \RightLabel{def}
            \UnaryInfC{$\Gamma, b : B \vdash \lambda x\ .\ (g\circ\const_b)(x) \equiv \lambda x\ .\ g(b) : A \rightarrow C$}
            \RightLabel{def}
            \UnaryInfC{$\Gamma, b : B \vdash \lambda x\ .\ (g\circ\const_b)(x) \equiv \const_g(b) : A \rightarrow C$}
            \RightLabel{$\eta$}
            \UnaryInfC{$\Gamma, b : B \vdash g\circ\const_b \equiv \const_g(b) : A \rightarrow C$}
            \DisplayProof
        \end{center}
    \end{proof}

    %%%%%%% LO SIGUIENTE QUEDA POR VER SI REALMENTE SE NECESITA... LO PRUEBO HASTA ENTONCES %%%%%%%%
    %\textbf{La función swap}\hfill\newline
    %La existencia de esta función testifica que el orden en el que ingresemos
    %los argumetos a una función no afecta el resultado.
    %\begin{center}
    %    \AxiomC{$\Gamma \vdash A\ \type$}
    %    \AxiomC{$\Gamma \vdash B\ \type$}
    %    \AxiomC{$\Gamma, x : A, y : B \vdash C(x,y)\ \type$}
    %    \TrinaryInfC{$\Gamma \vdash \sigma : \left(\prod_{(x:A)} \prod_{(y : B)} C(x, y)\right) \rightarrow \left(\prod_{(y : B)} \prod_{(x:A)} C(x, y)\right)$}
    %    \DisplayProof
    %\end{center}
    %{\small \textbf{Construcción}}\hfill\newline
    %{\small \textbf{Propiedades}}\hfill\newline
    %\begin{lemma}\hfill\newline
    %    \begin{center}
    %        \AxiomC{$\Gamma \vdash A\ \type$}
    %        \AxiomC{$\Gamma \vdash B\ \type$}
    %        \AxiomC{$\Gamma, x : A, y : B \vdash C(x,y)\ \type$}
    %        \TrinaryInfC{$\Gamma \vdash \sigma \circ \sigma \equiv \Id : \left(\prod_{(x:A)} \prod_{(y : B)} C(x, y)\right) \rightarrow \left(\prod_{(x : A)} \prod_{(y:B)} C(x, y)\right)$}
    %        \DisplayProof
    %    \end{center}
    %\end{lemma}

    \subsubsection{Tipos inductivos y coincidencia de patrones}
    
    Martin-Löf en \cite{Martin_L_f_1971} presenta un análisis desde el punto de
    vista de la teoría de la prueba sobre la teoría intuicionista de las
    definiciones inductivas generalizadas aplicadas de forma iterada un número
    finito de veces. En este análisis exhibe cómo una reformulación de estas
    reglas desemboca en una extensión del Haupstatz de Gentzen a la teoría
    de definiciones inductivas iteradas.\footnote{El Haupstatz de Gentzen 
    también es conocido como \textbf{el teorema de corte-eliminación} y con
    implicaciones fuertes, como permitir mostrar la inconsistencia de un 
    sistema, todo término de prueba se reduce a su forma normal en un número
    finito de pasos, o ser la justificación rigurosa de la correctud sobre
    introducir lemas auxiliares en la demostración de un teorema. En breve,
    la regla de corte-eliminación estipula:


    \begin{center}
        \AxiomC{$\Gamma, A \vdash B$}
        \AxiomC{$\Delta \vdash A$}
        \BinaryInfC{$\Delta, \Gamma \vdash B$}
        \DisplayProof
    \end{center}
 
    Y el Haupstatz afirma que en el cálculo de secuentes toda prueba
    sin la regla de corte pero con una regla adicional (llamada mix) se puede 
    reescribir como una prueba sin la regla adicional \cite{PaoloMancosu56}.
    } Justamente la teoría de definiciones inductivas iteradas es un predecesor
    de la teoría de tipos dependientes, tema que nos ocupa en este escrito.
    La forma en como Per Martin-Löf introduce las reglas de inferencia para los
    predicados definidos de forma inductiva es como a continuación:

    Antes de continuar, la notación $Qq(x)$ representa a tres objetos 
    interactuando: Q un símbolo de predicado n-ario, q una sucesión de $n$ 
    términos y $x$ denota a la totalidad de las variables que ocurren. 
    Ya con la notación acordada, entenderemos por producción a la forma general 
    siguiente:

    \begin{center}
        \AxiomC{$Qq(t)$}
        \AxiomC{$\dots$}
        \AxiomC{$Rr(t)$}
        \TrinaryInfC{$Pp(t)$}
        \DisplayProof
    \end{center}
    Una producción puede ser entendida como una regla de introducción para el
    predicado que ocurre en su conclusión.
    A esta figura le corresponden distintas variantes según las formas asociadas 
    a $\rightarrow$ y $\Pi$ las cuales son, respectivamente:
    
    
    \begin{center}
        \AxiomC{$[H(t)]$}
        \noLine
        \UnaryInfC{$\vdots$}
        \noLine
        \UnaryInfC{$Qq(t)$}
        \UnaryInfC{$Pp(t)$}
        \DisplayProof
        \hskip 1.5em 
        \AxiomC{$\prod{y} Qq(t, y)$}
        \UnaryInfC{$Pp(t)$}
        \DisplayProof
    \end{center}
    
    
    La regla $\Pi$-producción está sujeta a la condición de que $y$ no aparezca 
    en $t$ y no es libre en la deducción de $Qq(t, y)$.
    La regla de $\Pi$-producción nos dice que si tenemos un método que nos
    permite deducir $Qq(t, y)$ para cualquier $y$ con $t$ una secuencia de
    términos cerrados, entonces podemos deducir algún predicado $Pp(t)$.

    La gran idea está en la forma general de eliminación para predicados 
    definidos de forma inductiva y nos permitimos llamarla así por el simíl
    de las reglas de producción con reglas de introducción:

    \begin{center}
        \AxiomC{$Pt$}
        \AxiomC{deducciones}
        \noLine
        \UnaryInfC{mínimas}
        \BinaryInfC{$F(t)$}
        \DisplayProof
    \end{center}

    parte de la idea de la regla de eliminación descrita antes involucra lo que
    Per Martin-Löf describe por el encadenamiento de dos símbolos de predicado.
    El encadenamiento se define por las siguientes reglas:

    \begin{enumerate}
        \item Todo símbolo de predicado está encadenado consigo mismo.
        \item Si $P$ ocurre en la conclusión de una producción sencilla, 
              entonces $P$ está encadenado con los todos los símbolos de
              predicado que están encadenados con los términos inmediatos de
              la producción. Por ejemplo en la siguiente situación $P$ se
              encuentra encadenado con cada uno de los símbolos de predicado
              que se encuentran enlazados a $Q \dots R$:

              \begin{center}
                    \AxiomC{$Qq(t)$}
                    \AxiomC{$\dots$}
                    \AxiomC{$Rr(t)$}
                    \TrinaryInfC{$Pp(t)$}
                    \DisplayProof
              \end{center}
        \item Si $P$ forma parte de una producción $\Pi$ o $\rightarrow$,
              entonces $P$ está encadenado con todos y cada uno de los símbolos
              de predicado del "consecuente" de la producción. Por ejemplo en
              las siguientes situaciones $P$ se encuentra encadenado con $Q$:

              \begin{center}
                \AxiomC{$H(x)$}
                \noLine
                \UnaryInfC{$\vdots$}
                \noLine
                \UnaryInfC{$Qq(x)$}
                \UnaryInfC{$Pp(x)$}
                \DisplayProof
              \end{center}

              \begin{center}
                \AxiomC{$\prod{y} Qq(x, y)$}
                \UnaryInfC{$Pp(x)$}
                \DisplayProof
              \end{center}
    \end{enumerate}

    Bajo esta abstracción podemos codificar los números naturales o algo tan
    abstracto como la noción de igualdad.
    La forma que adoptan los números naturales bajo las nociones de 
    producción-eliminación son las siguientes, donde $N$ denotará la
    propiedad de ser un número natural y $E$ la propiedad de igualdad:
    \hfill\newline

    \textbf{\textit{Producción} de los números naturales}\hfill\newline
    
    \begin{center}
        \AxiomC{$N0$}
        \DisplayProof
        \hskip 1.5em
        \AxiomC{$Nx$}
        \UnaryInfC{$Nsx$}
        \DisplayProof
    \end{center}

    \textbf{\textit{Eliminación} de los números naturales}\hfill\newline
    En tanto que $0$ es tal que $N0$ y, si $x$ es tal que $Nx$ entonces
    $sx$ es tal que $Nsx$, temos entonces que cualquier $x$, tal que $Nx$, está 
    encadenado con $0$. Es por ello que si $F$ es alguna otra propiedad tal que
    $F0$, y para cualquier $x$ tal que $F(x)$ entonces $F(sx)$, entonces para
    cualquier otro $t$ tal que $Nt$ se tiene que $F(t)$ pues $t$ en particular
    actúa como cualquier $x$ en virtud de sus encadenamientos. 
    
    \begin{center}
        \AxiomC{$Nt$}
        \AxiomC{$F(0)$}
        \AxiomC{$[F(x)]$}
        \noLine
        \UnaryInfC{$\vdots$}
        \noLine
        \UnaryInfC{$F(sx)$}
        \TrinaryInfC{$F(t)$}
        \DisplayProof
    \end{center}

    que resulta ser la regla de inducción para los números naturales.
    \hfill\newline



    \textbf{\textit{Producción} de la igualdad}\hfill\newline
    La igualdad satisface la mínima propiedad de ser reflexiva, y esto
    puede ser descrito por la siguiente producción:

    \begin{center}
        \AxiomC{$Exx$}
        \DisplayProof
    \end{center}

    Siendo este el esquema de la propiedad de ser reflexiva.


    \textbf{\textit{Eliminación} de los números naturales}\hfill\newline
    La regla de eliminación para la producción anterior describe una regla de 
    congruencia bajo predicados.
    Consideremos $F(x,y)$ un predicado tal que $F(x, x)$ para cualquier $x$. 
    En particular notemos que $Exx$ se cumple para cualquier $x$ por
    el esquema de axioma definido por la regla de producción de $E$.
    Así, si fuera que $Euv$ para alunos $u$ y $v$ terminos cerrados, 
    entonces en particular $Euv$ estará ligado a $Euu$ y a $Evv$. Además, al ser 
    que $F(x, x)$ y $Exx$ para cualquier $x$, entonces $F(u, v)$.
    
    \begin{center}
        \AxiomC{$Euv$}
        \AxiomC{$F(x, x)$}
        \BinaryInfC{$F(u, v)$}
        \DisplayProof
    \end{center}

    La presentación moderna y relativamente madura de las ideas anteriormente
    descritas por Per Martin-Löf se pueden encontrar en \cite{Dybjer1991} y 
    también en \cite{EgbertRijke26}.

    
    
    \hfill\newline\textbf{Tipo unitario}\hfill\newline
    \hfill\newline\textbf{Tipo vacío}\hfill\newline
    \hfill\newline\textbf{Tipo producto}\hfill\newline
    \hfill\newline\textbf{Tipo co-producto}\hfill\newline

    \subsubsection{Pares dependientes}
    Los pares dependientes fueron concebidos originalmente por Per 
    Martin-L\"{o}f como un an\'{a}logo a la uni\'{o}n disjunta de una familia de 
    conjuntos \cite{PerMartin-Lof98}. Por lo tanto, en la teoría de tipos 
    dependientes el principio de considerar "pares" de elementos de una familia 
    de conjuntos conservando un elemento que apunta de qu\'{e} conjunto viene se 
    preserva. La representaci\'{o}n usual de la uni\'{o}n disjunta de conjuntos 
    es
    $$
        \coprod\limits_{i\in I} A_i = \bigcup\limits_{i\in I} \{(i, x) : x \in A_i\}
    $$
    Notemos que si $w \in \coprod A_i$, entonces es porque \textbf{existe}
    un \'{i}ndice $i \in I$ para el cual existe un $x$ tal que $x \in A_i$.
    Fundamentalmente $w$ cuenta entonces con la siguiente información:
    \begin{itemize}
        \item un \'{i}ndice que evidenc\'{i}a de la presencia de un elemento de 
        $A_i$ en la suma disjunta y,
        \item un elemento concreto que pertenece a $A_i$ y queda encapsulado por 
        $w = \picopar{i, x}$.
    \end{itemize}
    As\'{i} pues, es claro que tanto $x$ como $A_i$ dependen de $i$ para 
    exhibir su presencia dentro de la uni\'{o}n disjunta.
    Si sustituimos a la familia de conjuntos $\{A_i\}_{i\in I}$ por su 
    hom\'{o}logo en la teoría de tipos, 
    $$
        i : I \vdash x : A(i)
    $$
    lo anterior se reflejar\'{i}a en que tal estructura, de existir, sus 
    elementos can\'{o}nicos deberían tener la información an\'{a}loga:
    \begin{itemize}
        \item un \'{i}ndice $i : I$ que evidenc\'{i}a de la presencia de un 
        t\'{e}rmino de $A(i)$ en la estructura y,
        \item un elemento concreto $x$ que pertenece a $A(i)$ y queda 
        encapsulado por $\picopar{i : I, x : A(i)}$.
    \end{itemize}
    La existencia de esta estructura se postula, y se denominan
    \textbf{pares dependientes}, \textbf{tipo $\Sigma$}, 
    \textbf{co-producto dependiente} y \textbf{tipo suma dependiente} y 
    usualmente se denota por la letra griega may\'{u}scula $\Sigma$.
    Existen al menos dos formas de presentar al tipo de los pares dependientes:
    como fue concebido por Martin-Löf \footnote{La presentación clásica del tipo 
    $\Sigma$ se puede encontrar en \cite{UnivalentFoundationsProgram30} y en 
    \cite{PerMartin-Lof98}}, y como un tipo inductivo. En este escrito
    se empleará la forma inductiva de presentar a los tipos, por lo que la
    exposición seguirá de forma cercana a la que hace Egbert Rijke en 
    \cite{EgbertRijke26} y en mayor o menor medida a aquella seguida por el 
    Programa para los Fundamentos Univalentes \cite{UnivalentFoundationsProgram30}.
    \todo{cuales son verdaderamente las diferencias entre ambas exposiciones?}
    

    \begin{definition}[El tipo de los pares dependientes]
        \todo{Realmente la dependencia sobre el primer elemento en el par 
        dependiente solo es sobre el tipo del segundo elemento y no tambien puede
        ser sobre el mismo segundo elemento? i.e. $\picopar{x, y(x)}$ y no 
        $\picopar{x, y}$ en general?}
        Dada una familia de tipos $B$ sobre $A$, el tipo de pares dependientes
        se define como el tipo inductivo $\sum_{(x:A)} B(x)$ 
        \begin{center}
            \AxiomC{$\Gamma, x : A \vdash B(x)\ \type$}
            \RightLabel{$\Sigma$}
            \UnaryInfC{$\Gamma \vdash \sum_{(x:A)} B(x)$}
            \DisplayProof
        \end{center}
        acompañado de una función de emparejamiento:
        $$
            \pair : \prod_{(x:A)}\left(B(x) \rightarrow \sum_{(y:A)}B(y)\right)
        $$
        o equivalentemente
        \begin{center}
            \AxiomC{$\Gamma, x : A \vdash b : B(x)$}
            \UnaryInfC{$\pair(x, b) : \sum_{(y:A)}B(y)$}
            \DisplayProof
        \end{center}
        y el principio de inducción:
        \begin{center}
            \AxiomC{$\Gamma, p : \sum_{(x : A)} B(x) \vdash P(p)\ \type$}
            \UnaryInfC{$
            \ind_\Sigma : \left(
                \prod_{(x : A)} \prod_{(y : B(x))} P(\pair(x, y))
            \right)
            \rightarrow \left(\prod_{(z : \sum_{(x:A)} B(x))} P(z)\right)
            $}
            \DisplayProof
        \end{center}
        tal que satisface la regla de cómputo
        $$
            \ind_\Sigma (g, \pair(x,y)) \equiv g(x,y)
        $$
        \todo{quien es g?}
        Escribiremos $\picopar{x, y}$ en lugar de $\pair(x, y)$.
    \end{definition}

    \begin{remark}
        \todo{Entender bien esto :s}
        Alternativamente, una definición de una función dependiente
        $$
            f : \prod_{(z : \sum_{(x : A)} B(x))} P(z)
        $$
        por inducción utilizando una función
        $$
            g : \prod_{(x : A)} \prod_{y : B(y)}P((x, y))
        $$
        puede ser presentada por coincidencia de patrones de la siguiente forma:
        $$
            f(\pair(x,y)) := g(x,y)
        $$
    \end{remark}

    \begin{remark}
         Si queremos definir una función
         $$
            f : \prod_{(z : \sum_{(x : A)} B(x))} P(z)
         $$
         por $\Sigma$-inducción, entonces debemos asumir un par $\picopar{x, y}$
         consistente de $x : A$ y $y : B(x)$ con la meta en mente de construir
         un elemento del tipo $P(x,y)$. El principio de inducción de los tipos
         $\Sigma$ es por lo tanto el converso a la operación de currying, dado
         por la función
         $$
            \text{ev-pair} : \left(
                \prod_{(z : \sum_{(x : A)} B(x))} P(z)
            \right)
            \rightarrow
            \left(
                \prod_{(x : A)}\prod_{(y : B(x))} P(x, y)
            \right)
         $$
         dada por $f \mapsto \lambda x. \lambda y . f(x, y )$. El principio de
         inducción $\ind_\Sigma$ es por lo tanto también conocido como la
         operación de uncurrying.
    \end{remark}
    
    \begin{definition}
        Dados $\Gamma \vdash A\ \type$, $\Gamma x : A \vdash B(x)$
        Definimos la primera y segunda proyección por el principio de inducción
        del tipo $\Sigma$ como a continuación:
        \todo{Elaborar más en esto de "por inducción"}
        \hfill\newline\textbf{primera proyección}\hfill\newline
        \begin{align*}
            \pr_1 : \left(\sum_{(x : A)} B(x)\right) \rightarrow A\\
            \pr_1\picopar{x,y} \equiv x
        \end{align*}
        \hfill\newline\textbf{segunda proyección}\hfill\newline
        \begin{align*}
            \pr_2 : \prod_{(p : \sum_{(x : A)} B(x))} B(\pr_1(p))\\
            \pr_2\picopar{x,y} \equiv y
        \end{align*}
    \end{definition}

    Un caso especial del tipo $\Sigma$ ocurre cuando $B$ es una familia 
    constante sobre $A$, es decir, cuando $B$ solo es un tipo debilitado por $A$.
    En este caso, el tipo $\sum_{(x : A)} B$ es el tipo de los pares ordenados
    \textit{comunes y corrientes} donde $x : A$ y $y : B$ de modo que el tipo
    de $y$ no depende de $x$.

    \begin{definition}
        Si $A$ y $B$ son tipos en un contexto $\Gamma$, definimos su producto
        (cartesiano) $A\times B$ como
        \begin{center}
            \AxiomC{$\Gamma \vdash A\ \type$}
            \AxiomC{$\Gamma \vdash B\ \type$}
            \RightLabel{W}
            \BinaryInfC{$x : A \vdash B\ \type$}
            \UnaryInfC{$A \times B := \sum_{(x : A)} B(x)$}
            \DisplayProof
        \end{center}    
    \end{definition}
    En tanto que el producto se define mediante el tipo $\Sigma$, se tiene 
    entonces que este tipo también satisface la regla de inducción de los tipos
    $\Sigma$. Para este caso particular la regla de inducción esatablece que
    para cualquier familia $P$ sobre $A \times B$ existe una función
    $$
        \ind_\times : \left(
            \prod_{(x : A)} \prod_{(y : B)} P(x, y)
        \right) \rightarrow
        \left(\prod_{(z : A \times B)} P(z)\right)
    $$
    tal que satisface la regla de cómputo
    $$
        \ind_{\times}(g, \picopar{x, y}) \equiv g(x, y)
    $$
    Así también las proyecciones se definen de manera análoga para el tipo 
    producto.
    \todo{hacer explícita acá la definición}
    \subsubsection{Breve comentario sobre la correspondencia Curry-Howard-Lambek}
    \todo{decidir si esto sí va aquí o antes hmm}
    \todo{acá iría la parte de lógica proposicional en agda uwu (ejercicios de la sección 4)}
    \subsubsection{Tipos de identidad}

    \subsubsection{Universos de tipos}
        La teoría de conjuntos permite tener conjuntos cuyos elementos son 
        conjuntos. De manera similar, la teoría de tipos ofrece un mecanismo
        para definir tipos cuyos términos son también tipos. Los 
        \textbf{universos} de tipos consisten de un tipo $\mathfrak{U}$ junto
        con una familia de tipos $\mathfrak{T}$ definida sobre $\mathfrak{U}$.
        La idea es pensar que dado $X : \mathfrak{U}$, $\mathfrak{T}(X)$ es
        una "\textit{interpretación}" externa a $\mathfrak{U}$ de $X$.
        \begin{definition}[Universo]
            Un universo es un tipo $\mathfrak{U}$ junto con una familia
            $\mathfrak{U}$ sobre $\mathfrak{U}$ llamada 
            \textit{familia universal} tales que satisfacen los siguientes
            axiomas:

            \begin{itemize}
                \item $\mathfrak{U}$ es tal que existe 
                $$
                \check{\Pi} : \prod_{X : \mathfrak{U}} 
                    (\mathfrak{T}(X) \rightarrow \mathfrak{U}) 
                        \rightarrow \mathfrak{U}
                $$
                tal que satisface la siguiente igualdad de juicio:
                $$
                    \mathfrak{T}(\check{\Pi(X,Y)}) \equiv 
                        \prod_{x : \mathfrak{T}(X)} \mathfrak{T}(Y(x))
                $$
                para cualesquiera $X : \mathfrak{U}$ y 
                    $Y : \mathfrak{T}(X) \rightarrow \mathfrak{U}$.
                \item $\mathfrak{U}$ es tal que existe
                $$
                \check{\Sigma} : \prod_{X : \mathfrak{U}} 
                    (\mathfrak{T}(X) \rightarrow \mathfrak{U}) 
                        \rightarrow \mathfrak{U}
                $$
                tal que satisface la siguiente igualdad de juicio:
                $$
                    \mathfrak{T}(\Sigma(X,Y)) \equiv 
                        \sum\limits_{x : \mathfrak{T}(X)}\mathfrak{T}(Y(x))
                $$
                para cualesquiera $X : \mathfrak{U}$ y 
                $Y : \mathfrak{T}(X) \rightarrow \mathfrak{U}$.
                \item $\mathfrak{U}$ es tal que existe
                $$
                    \check{I} : \prod_{X : \mathfrak{U}} \mathfrak{T}(X)  
                        \rightarrow (\mathfrak{T}(X) \rightarrow \mathfrak{U})
                $$
                tal que satisface la siguiente igualdad de juicio:
                $$
                    \mathfrak{T}(\check{I}(X, x, y)) \equiv (x = y)
                $$
                para cualesquiera $X : \mathfrak{U}$ y $x,y : \mathfrak{T}(X)$.
                \item $\mathfrak{U}$ es tal que existe 
                $$
                    \check{+}:\mathfrak{U} \rightarrow \mathfrak{U} 
                        \rightarrow \mathfrak{U}
                $$
                tal que satisface la igualdad de juicio
                $$
                    \mathfrak{T}(X \check{+} Y) \equiv 
                        \mathfrak{T}(X) + \mathfrak{T}(Y)
                $$
                \item $\mathfrak{U}$ es tal que existen $\check{\mathbb{1}}, 
                \check{\mathbb{0}}, \check{\mathbb{N}}$ tales que satisfacen las 
                siguientes igualdades de juicio:
                \begin{align*}
                    \mathfrak{T}(\check{\mathbb{1}}) \equiv \mathbb{1}\\
                    \mathfrak{T}(\check{\mathbb{0}}) \equiv \mathbb{0}\\
                    \mathfrak{T}(\check{\mathbb{N}}) \equiv \mathbb{N}
                \end{align*}
            \end{itemize}
            
        \end{definition}

\subsubsection{Aritmética modular}

\subsubsection{Equivalencia}
    \subsubsection{Equivalencias entre tipos}
\subsection{El teorema fundamental de los tipos de identidad}
\subsection{Proposiciones, conjuntos y niveles superiores de truncamiento}
\subsection{Extensionalidad de funciones}
\subsection{Truncamientos proposicionales}
\subsubsection{Lógica en teoría de tipos}
\subsection{Factorización de imágenes}
\subsection{Tipos finitos}
\subsection{El axioma de univalencia}
\subsection{Cocientes de conjuntos}

\bibliography{biblio}
\bibliographystyle{plain}

\end{document}

